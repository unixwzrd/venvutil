#!/usr/bin/env bash
#
# genmd - Combined source code markdown generator.
#
# `genmd` is a versatile Bash script designed to generate comprehensive Markdown documentation
# from your source code files. It scans directories, includes or excludes files based on
# specified patterns, and consolidates the content into a structured Markdown file.
# Additionally, it can generate a visual directory structure and manage configurations through
# dedicated files.
#
# Usage:
#     genmd [options]
# 
# Options:
#     -d, --debug [level]       Set debug level (0-9)
#                               0: No debug output
#                               1: Show informational messages
#                               2: Show debug messages
#                               3: Show regex commands and patterns
#                               9: Show xtrace messages
# 
#     -h, --help                Show this help message
# 
#     -e, --exclude [patterns]  Exclude directories matching the given patterns.
#                               Multiple patterns can be separated by '|' or spaces.
# 
#     -f, --file [patterns]     Exclude files matching the given patterns.
#                               Multiple patterns can be separated by '|' or spaces.
# 
#     -p, --pattern [patterns]  Exclude additional patterns matching the given strings.
#                               Multiple patterns can be separated by '|' or spaces.
# 
#     -i, --include [patterns]  Include files matching the given patterns.
#                               Multiple patterns can be separated by '|' or spaces.
# 
#     -o, --output [filename]   Output file (default: combined_source.md)
# 
#     -c, --config [filename]   Load configuration from a .grc or .cfg file.
#                               If the filename does not end with .grc or .cfg, .grc will be appended.
# 
#     -s, --settings [modes]    Show settings. Modes can be:
#                               info    Show current settings
#                               cfg     Write to configuration file
#                               md      Include settings in markdown output
#                               env     Output settings as environment variables
#                               all     Perform info, md, and env actions
# 
#     -n, --dry-run             Do not write the output file; print the files to be processed.
# 
#     -v, --verbose             Show verbose output
# 
#     -g, --no-gitignore        Disable integration with .gitignore patterns.
#                               By default, genmd uses patterns from .gitignore to exclude files
#                               and directories. Use this flag to disable this behavior.
# 
#     -C, --no-config           Run without sourcing the .grc configuration file.
#                               This allows you to execute genmd using only the provided
#                               command-line options and .gitignore patterns (if enabled).
# 
# Description:
#       The genmd script generates markdown from the files in the specified directory,
#       excluding files and directories based on provided patterns. It outputs:
#       - Project filesystem directory structure
#       - Source code in a single markdown file for all included files.
#       - Excluded files are omitted based on exclusion patterns.
#       - Configuration file will be read if the `-c` option is used, and it assumes .grc is the 
#         file extension and the file is in the GENMD_BASE/utils/etc directory.
#       - Configuration file will be written if -o is used and will be placed in the
#         GENMD_BASE/utils/etc directory and will have the same name as the output file with
#         .grc appended.
#       - All exit codes are POSIX exit codes.
#   
#       - Will use .gitignore patterns by default unless -g is used to reduce redundancy in your
#         `.grc` files.
#
# Examples:
#       genmd -e "node_modules|dist" -f "*.log *.tmp"  -i "*css *.js" -s "info,md" \
#             -o project_overview.md
#       genmd --exclude "node_modules|dist" --file "*.log *.tmp" --include "info" --dry-run
#       genmd -s info,md -d 2
#
# Environment:
#     GENMD_BASE: The base directory to search for files in.
#     GENMD_DIR_EXCLUDES: A default list of directory patterns to exclude from the generated
#                        markdown.
#     GENMD_FILE_EXCLUDES: A default list of file patterns to exclude from the generated markdown.
#     GENMD_PATTERN_EXCLUDES: A default list of additional patterns to exclude from the generated
#                            markdown.
#     GENMD_FILE_INCLUDES: A default list of file patterns to include in the generated markdown.
#     PAGER: The pager to use for output, defaults to `less -R`
# 
# Files and directories:
#     Files are located in the GENMD_BASE directory.
#     - utils/etc/genmd.grc: Default configuration file.
#     - utils/etc: Default directory for configuration files.
#     - utils/output: Default directory for output files.
# 
# Dependencies:
#     - bash 4.0 or higher
#     - filetree, located in this repository
#         https://github.com/unixwzrd/venvutil
#     - filetree requires the Rich Python library. 
#     
# Author:
#     Michael Sullivan <unixwzrd@unixwzrd.ai>
#         https://unixwzrd.ai/
#         https://github.com/unixwzrd
# 
# License:
#     Apache License, Version 2.0
#

# Ensure the script exits on error and treats unset variables as errors
set -euo pipefail

# Declare arrays
declare -a dir_excludes=(i".git")
declare -a file_excludes=()
declare -a pattern_excludes=()
declare -a file_includes=()
declare -a gitignore_exclude=()
declare -a gitignore_include=()

# Get the base directory
GENMD_BASE="${GENMD_BASE:-${BASE_DIR:-"."}}"
my_name="$(basename "${BASH_SOURCE[0]}")"
echo "INFO ($my_name): Using base directory - $GENMD_BASE" >&2

# Check for Bash version 4+
if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    echo "ERROR ($my_name): genmd requires Bash version 4 or higher." >&2
    exit 75     # (EPROGMISMATCH: 75): Program version wrong
fi

PAGER="${PAGER:-less -R}"

# Define a list of variable names to display or save.
settings_variables=(
    "GENMD_FILE_EXCLUDES"
    "GENMD_DIR_EXCLUDES"
    "GENMD_PATTERN_EXCLUDES"
    "GENMD_FILE_INCLUDES"
    "GENMD_BASE"
    "output_filename"
    "dry_run"
    "debug_level"
    "verbose"
    "use_gitignore"
)

# Set default flag values.
dry_run=false
debug_level=0
verbose=false
settings_modes=("md")
use_gitignore=true  # Default to using .gitignore

# Define default directory
default_filename="combined_source"
output_dir="$GENMD_BASE/utils/output"
config_dir="$GENMD_BASE/utils/etc"
specified_config=""
specified_output=""
skip_config=false  # New flag to skip .grc config file

# Function to ensure directories exist
ensure_directory_exists() {
    local dir_path="$1"
    if [[ ! -d "$dir_path" ]]; then
        mkdir -p "$dir_path" || { echo "ERROR Failed to create directory \"$dir_path\"." >&2
                    exit 1  # (EPERM: 1): Operation not permitted
                }
    fi
}

# Function to remove duplicates from an array
remove_duplicates() {
    local -n arr_ref=$1
    declare -A seen
    local unique=()
    echo "INFO ($my_name): Removing duplicates from array '$1': '${arr_ref[*]}'"
    
    for regex in "${arr_ref[@]}"; do
        # Skip empty patterns
        [[ -n "$regex" ]] || continue

        if [[ $debug_level -gt 1 ]]; then
            echo "DEBUG ($my_name): remove_duplicates input regex: $regex" >&2
        fi

        if [[ -z "${seen[$regex]+_}" ]]; then
            seen["$regex"]=1
            unique+=("$regex")
        fi
    done

    echo "INFO ($my_name): Finished removing duplicates from array '$1': '${unique[*]}'"
    arr_ref=("${unique[@]}")
}

# Function to parse .gitignore and populate gitignore_exclude and gitignore_include
parse_gitignore() {
    local gitignore_file="$GENMD_BASE/.gitignore"
    
    if [[ -f "$gitignore_file" ]]; then
        echo "INFO ($my_name): Parsing .gitignore file: $gitignore_file" >&2
        
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Trim leading and trailing whitespace
            line="$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
            
            # Skip empty lines and comments
            if [[ -z "$line" || "$line" =~ ^# ]]; then
                continue
            fi
            
            # Check for negation patterns
            if [[ "$line" =~ ^! ]]; then
                # Remove the '!' and add to gitignore_include
                pattern="${line:1}"
                gitignore_include+=("$pattern")
                if [[ $debug_level -gt 1 ]]; then
                    echo "DEBUG ($my_name): Parsed .gitignore include pattern: $pattern" >&2
                fi
            else
                # Regular exclusion pattern
                gitignore_exclude+=("$line")
                if [[ $debug_level -gt 1 ]]; then
                    echo "DEBUG ($my_name): Parsed .gitignore exclude pattern: $line" >&2
                fi
            fi
        done < "$gitignore_file"
    else
        echo "INFO ($my_name): No .gitignore file found at $gitignore_file. Skipping .gitignore integration." >&2
    fi
}

# Function to display short help message
display_help() {
    # Initialize a variable to hold the help text
    local message=$1
    local help_text=""
    
    # Read the script file line by line
    help_text+="$message"$'\n\n'
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip the shebang line
        if [[ "$line" =~ ^#!/ ]]; then
            continue
        fi
        if [[ "$line" =~ ^$ ]]; then
            break
        fi
        if [[ "$line" =~ ^\#$ ]]; then
            help_text+=$'\n'
            continue
        fi
        if [[ "$line" =~ ^\#[[:space:]]* ]]; then
            help_text+="${line//\# /}"$'\n'
            continue
        fi
    done < "$0"

    printf "%s" "$help_text" | ${PAGER:-cat}
    exit 22     # (EINVAL: 22): Invalid argument
}

# Function to display or write out the current settings
display_settings() {
    local -n modes=$1  # Array of modes passed to the function

    if [[ "${modes[*]}" =~ "all" ]]; then
        modes=("info" "md" "cfg" "env")
    fi

    for mode in "${modes[@]}"; do
        case "$mode" in
            info)
                echo "genmd current settings" >&2
                for var in "${settings_variables[@]}"; do
                    echo "$var:    ${!var}" >&2
                done
                ;;
            md)
                {
                    echo "## genmd Settings"
                    echo ""
                    echo "| Variable               | Value                                                                 |"
                    echo "|------------------------|-----------------------------------------------------------------------|"
                    for var in "${settings_variables[@]}"; do
                        local value="${!var}"
                        value="${value//|/\\|}"
                        echo "| $var | $value |"
                    done
                    echo ""
                } >> "$output_filename"
                ;;
            cfg)
                save_config
                ;;
            env)
                {
                    echo ""
                    echo "## genmd Environment Variables"
                    echo ""
                    for var in "${settings_variables[@]}"; do
                        echo "export $var=\"${!var}\""
                    done
                    echo ""
                } > "${GENMD_BASE}/genmd_env.sh"
                ;;
            *)
                echo "ERROR Unknown mode '$mode' for --settings" >&2
                exit 22     # (EINVAL: 22): Invalid argument
                ;;
        esac
    done
}

# Function to build a single regex pattern from an array of patterns
build_regex() {
    local caller_message="$1"
    local -n patterns_ref=$2  # Reference to the array
    local regex=""
    local escaped_pattern

    if [[ $debug_level -gt 1 ]]; then
        # Argument mixes string and array. Use * or separate argument
        # shellcheck disable=SC2145
        echo "DEBUG ($my_name): $caller_message patterns: ${patterns_ref[@]}" >&2
    fi

    for pattern in "${patterns_ref[@]}"; do
        if [[ $debug_level -gt 2 ]]; then
            echo "DEBUG ($my_name): $caller_message input pattern: $pattern" >&2
        fi
        # Escape special regex characters except for '*' and '|'
        escaped_pattern=$(printf "%s" "$pattern" | sed -E 's/([.+^|(){}])/\\\1/g')
        # Replace '*' with '.*' for wildcard matching
        escaped_pattern=${escaped_pattern//\*/.*}
        if [[ $debug_level -gt 2 ]]; then
            echo "DEBUG ($my_name): $caller_message escaped pattern: $escaped_pattern" >&2
        fi
        if [[ -z "$regex" ]]; then
            regex="$escaped_pattern"
        else
            regex="$regex|$escaped_pattern"
        fi
    done

    if [[ $debug_level -gt 1 ]]; then
        echo "DEBUG ($my_name): $caller_message final regex: $regex" >&2
    fi

    echo "$regex"
}

# Function to build a list of files to include in the combined source
build_file_list() {
    local -n files_ref=$1
    local -n include_files_ref=$2
    local -n exclude_files_ref=$3
    local -n exclude_dirs_ref=$4
    local -n pattern_excludes_ref=$5

    # Change to GENMD_BASE and perform find
    cd "$GENMD_BASE"
    readarray -t files < <(find . -type f | sort -u)

    # Exclude directories in the exclude directory list
    if [[ ${#exclude_dirs_ref[@]} -gt 0 ]]; then
        local dir_regex
        dir_regex=$(build_regex "Exclude directories" "exclude_dirs_ref" | sed -E 's/([^|]+)/\/\1\//g')
        if [[ $debug_level -gt 2 ]]; then
            echo "DEBUG ($my_name): Excluding directories with regex: $dir_regex" >&2
        fi
        # Remove files within excluded directories
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -vE "($dir_regex)")
    fi

    # Exclude files based on file patterns
    if [[ ${#exclude_files_ref[@]} -gt 0 ]]; then
        local exclude_files_regex
        exclude_files_regex=$(build_regex "Exclude files" "exclude_files_ref")
        if [[ $debug_level -gt 2 ]]; then
            echo "DEBUG ($my_name): Excluding files with regex: $exclude_files_regex" >&2
        fi
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -vE "$exclude_files_regex")
    fi

    # Exclude files based on .gitignore exclude patterns
    if [[ ${#gitignore_exclude[@]} -gt 0 ]]; then
        local git_exclude_regex
        git_exclude_regex=$(build_regex "Gitignore exclude" "gitignore_exclude")
        if [[ $debug_level -gt 2 ]]; then
            echo "DEBUG ($my_name): Excluding files with Gitignore exclude regex: $git_exclude_regex" >&2
        fi
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -vE "$git_exclude_regex")
    fi

    # Exclude any strings in the extra pattern list
    if [[ ${#pattern_excludes_ref[@]} -gt 0 ]]; then
        local pattern_excludes_regex
        pattern_excludes_regex=$(build_regex "Exclude patterns" "pattern_excludes_ref")
        if [[ $debug_level -gt 2 ]]; then
            echo "DEBUG ($my_name): Excluding patterns with regex: $pattern_excludes_regex" >&2
        fi
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -vE "$pattern_excludes_regex")
    fi

    # Re-include files based on .gitignore include patterns
    if [[ "${use_gitignore}" = true && ${#gitignore_include[@]} -gt 0 ]]; then
        local git_include_regex
        git_include_regex=$(build_regex "Gitignore include" "gitignore_include")
        if [[ $debug_level -gt 2 ]]; then
            echo "DEBUG ($my_name): Including files with Gitignore include regex: $git_include_regex" >&2
        fi
        # Find files that match include patterns and add them back
        readarray -t included_files < <(find . -type f | grep -E "$git_include_regex")
        files=($(printf "%s\n" "${files[@]}" "${included_files[@]}" | sort -u))
    fi

    # Include only files explicitly specified in the include file list
    if [[ ${#include_files_ref[@]} -gt 0 ]]; then
        local include_files_regex
        include_files_regex=$(build_regex "Include files" "include_files_ref")
        if [[ $debug_level -gt 2 ]]; then
            echo "DEBUG ($my_name): Including files with regex: $include_files_regex" >&2
        fi
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -E "$include_files_regex")
    fi

    # Passing back the array reference
    files_ref=("${files[@]}")
}

# Function to generate markdown for a source file
generate_markdown() {
    local source_file="$1"
    local markdown_type="$2"

    if [[ "$dry_run" = true ]]; then
        echo "Dry run: Would generate markdown type '$markdown_type' for: $source_file" >&2
        return
    fi

    if [[ "$verbose" = true || $debug_level -gt 0 ]]; then
        echo "INFO ($my_name): Generating markdown for: $source_file" >&2
    fi

    {
        printf "\n\n## Filename ==>  %s\n\`\`\`%s\n" "$source_file" "$markdown_type"
        cat "$source_file"
        printf "\n\`\`\`\n"
    } >> "$output_filename"
}

# Function to generate the filetree markdown
generate_filetree() {
    local output_filename="$1"
    shift
    local exclude_list=("$@")
    if [[ $debug_level -gt 0 ]]; then
        echo "INFO ($my_name): Generating directory and file structure excluding: ${exclude_list[*]}" >&2
    fi

    if ! command -v filetree >/dev/null 2>&1; then
        printf "ERROR 'filetree' command not found. Please install it or use an alternative.\n" >&2
        printf "It should have been included with this script and it should be in your \$PATH.\n" >&2
        exit 2  # (ENOENT: 2): No such file or directory
    fi

    if [[ "$dry_run" = true ]]; then
        echo "Dry run: Generating directory and file structure." >&2
        filetree --exclude "${exclude_list[@]}"
        return
    fi

    {
        printf "\n\n## Project filesystem directory structure\n\`\`\`text\n"
        filetree --exclude "${exclude_list[@]}"
        printf "\n\`\`\`\n"
    } >> "$output_filename"
}

# Function to get the file type using the `file` command
get_unknown_filetype() {
    local file_path="$1"
    local file_description
    file_description=$(file -b "$file_path")
    case "$file_description" in
        *Bourne-Again*) echo "bash";;
        *Bourne*) echo "sh";;
        *HTML*) echo "html";;
        *JSON*) echo "json";;
        *JavaScript*) echo "javascript";;
        *Java*) echo "java";;
        *Markdown*) echo "markdown";;
        *PHP*) echo "php";;
        *[Pp]erl*) echo "perl";;
        *Python*) echo "python";;
        *[Rr]uby*) echo "ruby";;
        *SASS*) echo "sass";;
        *SCSS*) echo "scss";;
        *CSS*) echo "css";;
        *shell*) echo "sh";;
        *Shell*) echo "bash";;
        *[Tt]ext*) echo "text";;
        *YAML*) echo "yaml";;
        *) echo "unknown";;
    esac
}

# Function to process a list of files and generate markdown
process_files(){
    local output_filename="$1"
    # Variable was used as an array but is now assigned a string.
    # shellcheck disable=2178
    local -n files_ref="$2"
    # Iterate over files and generate markdown
    for file in "${files_ref[@]}"; do
        # Determine file type based on extension
        local filetype
        case "$file" in
            *".css") filetype="css";;
            *".html") filetype="html";;
            *".js") filetype="javascript";;
            *".json") filetype="json";;
            *".md") filetype="markdown";;
            *".py") filetype="python";;
            *".rb") filetype="ruby";;
            *".sass") filetype="sass";;
            *".scss") filetype="scss";;
            *".sh") filetype="bash";;
            *".txt") filetype="text";;
            *".yml") filetype="yaml";;
            # Resolve any types which don't have a known extension using file magic
            *) filetype=$(get_unknown_filetype "$file");;
        esac
        if [[ "$filetype" = "unknown" ]]; then
            echo "INFO ($my_name): Skipping unknown file type: \"$file\"" >&2
            continue
        fi
        generate_markdown "$file" "$filetype"
    done
}

# Function to set environment variables from internal arrays
set_env_vars() {
    readarray -t GENMD_DIR_EXCLUDES < <( printf "%s\n" "${dir_excludes[@]}" )
    readarray -t GENMD_FILE_EXCLUDES < <( printf "%s\n" "${file_excludes[@]}" )
    readarray -t GENMD_FILE_INCLUDES < <( printf "%s\n" "${file_includes[@]}" )
    readarray -t GENMD_PATTERN_EXCLUDES < <( printf "%s\n" "${pattern_excludes[@]}" )
}

# Function to save configuration to a .grc file
save_config() {
    local config_file="${config_filename_out}"
    ensure_directory_exists "$(dirname "$config_file")"

    {
        echo "export GENMD_DIR_EXCLUDES=\"${dir_excludes[*]}\""
        echo "export GENMD_FILE_EXCLUDES=\"${file_excludes[*]}\""
        echo "export GENMD_FILE_INCLUDES=\"${file_includes[*]}\""
        echo "export GENMD_PATTERN_EXCLUDES=\"${pattern_excludes[*]}\""
        echo "export GENMD_BASE=\"$GENMD_BASE\""
        echo "output_filename=\"$output_filename\""
        echo "settings_modes=\"${settings_modes[*]}\""
        echo "dry_run=$dry_run"
        echo "debug_level=$debug_level"
        echo "verbose=$verbose"
        echo "use_gitignore=$use_gitignore"  # Save gitignore usage
    } > "$config_file"
    echo "INFO ($my_name): Configuration saved to $config_file" >&2
}

# Function to validate patterns (optional enhancement)
validate_pattern() {
    local pattern="$1"
    if ! echo "" | grep -E "$pattern" >/dev/null 2>&1; then
        echo "ERROR ($my_name): Invalid pattern '$pattern'." >&2
        exit 22 # (EINVAL: 22): Invalid argument
    fi
}

# Process command-line options using getopts
# Reset OPTIND in case getopts has been used previously
OPTIND=1

while getopts ":d:he:f:i:p:o:c:s:nvgC-:" opt; do
    case "$opt" in
        # Short options
        d)
            if [[ "$OPTARG" =~ ^[0-9]$ ]]; then
                debug_level="$OPTARG"
                if [[ "$debug_level" -eq 9 ]]; then
                    set -x
                fi
            else
                display_help "ERROR ($my_name): Debug level must be between 0 and 9."
            fi
            ;;
        e)
            if [[ -n "$OPTARG" && ! "$OPTARG" =~ ^- ]]; then
                IFS='| ' read -r -a values <<< "$OPTARG"
                for pattern in "${values[@]}"; do
                    dir_excludes+=("$pattern")
                done
            else
                display_help "ERROR ($my_name): -e requires a directory pattern string."
            fi
            ;;
        f)
            if [[ -n "$OPTARG" && ! "$OPTARG" =~ ^- ]]; then
                IFS='| ' read -r -a values <<< "$OPTARG"
                for pattern in "${values[@]}"; do
                    file_excludes+=("$pattern")
                done
            else
                display_help "ERROR ($my_name): -f requires a file pattern string."
            fi
            ;;
        i)
            if [[ -n "$OPTARG" && ! "$OPTARG" =~ ^- ]]; then
                IFS='| ' read -r -a values <<< "$OPTARG"
                for pattern in "${values[@]}"; do
                    file_includes+=("$pattern")
                done
            else
                display_help "ERROR ($my_name): -i requires a file pattern string."
            fi
            ;;
        p)
            if [[ -n "$OPTARG" && ! "$OPTARG" =~ ^- ]]; then
                IFS='| ' read -r -a values <<< "$OPTARG"
                for pattern in "${values[@]}"; do
                    pattern_excludes+=("$pattern")
                done
            else
                display_help "ERROR ($my_name): -p requires a pattern string."
            fi
            ;;
        o)
            value="${OPTARG#*=}"
            specified_output="$(basename "$value" .md)"
            ;;
        c)
            value="${OPTARG#*=}"
            specified_config="$(basename "$value" .grc)"
            ;;
        s)
            if [[ -n "$OPTARG" && ! "$OPTARG" =~ ^- ]]; then
                IFS=' ' read -r -a values <<< "$OPTARG"
                for mode in "${values[@]}"; do
                    settings_modes+=("$mode")
                done
            else
                display_help "ERROR ($my_name): -s requires a setting pattern string."
            fi
            ;;
        n)
            dry_run=true
            ;;
        v)
            verbose=true
            ;;
        g)
            use_gitignore=false  # Disable gitignore integration
            ;;
        C)
            skip_config=true  # New option to skip config files
            ;;
        h)
            display_help ""
            ;;
        -)
            # Handle long options manually
            case "${OPTARG}" in
                debug=*)
                    debug_level="${OPTARG#*=}"
                    if [[ "$debug_level" =~ ^[0-9]$ ]]; then
                        if [[ "$debug_level" -eq 9 ]]; then
                            set -x
                        fi
                    else
                        display_help "ERROR ($my_name): Debug level must be between 0 and 9."
                    fi
                    ;;
                help)
                    display_help ""
                    ;;
                exclude=*)
                    if [[ -n "${OPTARG#*=}" && ! "${OPTARG#*=}" =~ ^- ]]; then
                        IFS='| ' read -r -a values <<< "${OPTARG#*=}"
                        for pattern in "${values[@]}"; do
                            dir_excludes+=("$pattern")
                        done
                    else
                        display_help "ERROR ($my_name): --exclude requires a directory pattern string."
                    fi
                    ;;
                file=*)
                    if [[ -n "${OPTARG#*=}" && ! "${OPTARG#*=}" =~ ^- ]]; then
                        IFS='| ' read -r -a values <<< "${OPTARG#*=}"
                        for pattern in "${values[@]}"; do
                            file_excludes+=("$pattern")
                        done
                    else
                        display_help "ERROR ($my_name): --file requires a file pattern string."
                    fi
                    ;;
                include=*)
                    if [[ -n "${OPTARG#*=}" && ! "${OPTARG#*=}" =~ ^- ]]; then
                        IFS='| ' read -r -a values <<< "${OPTARG#*=}"
                        for pattern in "${values[@]}"; do
                            file_includes+=("$pattern")
                        done
                    else
                        display_help "ERROR ($my_name): --include requires a file pattern string."
                    fi
                    ;;
                pattern=*)
                    if [[ -n "${OPTARG#*=}" && ! "${OPTARG#*=}" =~ ^- ]]; then
                        IFS='| ' read -r -a values <<< "${OPTARG#*=}"
                        for pattern in "${values[@]}"; do
                            pattern_excludes+=("$pattern")
                        done
                    else
                        display_help "ERROR ($my_name): --pattern requires a pattern string."
                    fi
                    ;;
                output=*)
                    value="${OPTARG#*=}"
                    specified_output="$(basename "$value" .md)"
                    ;;
                config=*)
                    value="${OPTARG#*=}"
                    specified_config="$(basename "$value" .grc)"
                    ;;
                settings=*)
                    if [[ -n "${OPTARG#*=}" && ! "${OPTARG#*=}" =~ ^- ]]; then
                        IFS=' ' read -r -a values <<< "${OPTARG#*=}"
                        for mode in "${values[@]}"; do
                            settings_modes+=("$mode")
                        done
                    else
                        display_help "ERROR ($my_name): --settings requires a setting pattern string."
                    fi
                    ;;
                no-gitignore)
                    use_gitignore=false
                    ;;
                no-config)
                    skip_config=true
                    ;;
                *)
                    display_help "ERROR ($my_name): Unknown option '--${OPTARG}'"
                    ;;
            esac
            ;;
        \?)
            display_help "ERROR ($my_name): Invalid option '-$OPTARG'"
            ;;
        :)
            display_help "ERROR ($my_name): Option '-$OPTARG' requires an argument."
            ;;
        ?)
            display_help "ERROR ($my_name): Unknown option '-$OPTARG'"
            ;;
    esac
done

# Shift off the options and optional --
shift $((OPTIND -1))

# Ensure necessary directories exist
ensure_directory_exists "$output_dir"
ensure_directory_exists "$config_dir"

# Now set the final values for output files after options have been processed
output_filename="${output_dir}/${default_filename}.md"
config_filename_in="${config_dir}/${default_filename}.grc"
config_filename_out="$config_filename_in"

# If a config file is specified and not skipped, we will load it and use it to override the defaults
if [[ "$skip_config" = false && -n "$specified_config" ]]; then
    # Specified a config file on the command line
    specified_config=${specified_config%.grc}
    config_filename_in=${config_dir}/${specified_config}.grc
    config_filename_out=$config_filename_in
    output_filename=${output_dir}/${specified_config}.md
    if [[ -e "$config_filename_in" ]]; then
        # shellcheck disable=SC1090
        source "$config_filename_in"
        echo "INFO ($my_name): Configuration loaded from \"$config_filename_in\"" >&2
        
        # Split the space-separated strings into arrays
        for pattern in $GENMD_DIR_EXCLUDES; do
            dir_excludes+=("$pattern")
        done
        for pattern in $GENMD_FILE_EXCLUDES; do
            file_excludes+=("$pattern")
        done
        for pattern in $GENMD_PATTERN_EXCLUDES; do
            pattern_excludes+=("$pattern")
        done
        for pattern in $GENMD_FILE_INCLUDES; do
            file_includes+=("$pattern")
        done
        # Load gitignore usage from config if present
        if [[ -n "${use_gitignore:-}" ]]; then
            use_gitignore="$use_gitignore"
        fi
    else
        echo "ERROR ($my_name): Configuration file \"$config_filename_in\" not found" >&2
        exit 2  # (ENOENT: 2): No such file or directory
    fi
fi

# If an output file is specified, handle it
if [[ -n "$specified_output" ]]; then
    specified_output=$(basename "$specified_output" .md)
    output_filename="${output_dir}/${specified_output}.md"
    config_filename_out="${config_dir}/${specified_output}.grc"
    if [[ "$skip_config" = false && -z "$specified_config" ]]; then
        config_filename_in="${config_dir}/${specified_output}.grc"
        config_filename_out="${config_dir}/${specified_output}.grc"
        if [[ -e "$config_filename_in" ]]; then
            # shellcheck disable=SC1090
            source "$config_filename_in"
            echo "INFO ($my_name): Configuration loaded from \"$config_filename_in\"" >&2
            
            # Split the space-separated strings into arrays
            for pattern in $GENMD_DIR_EXCLUDES; do
                dir_excludes+=("$pattern")
            done
            for pattern in $GENMD_FILE_EXCLUDES; do
                file_excludes+=("$pattern")
            done
            for pattern in $GENMD_PATTERN_EXCLUDES; do
                pattern_excludes+=("$pattern")
            done
            for pattern in $GENMD_FILE_INCLUDES; do
                file_includes+=("$pattern")
            done
            # Load gitignore usage from config if present
            if [[ -n "${use_gitignore:-}" ]]; then
                use_gitignore="$use_gitignore"
            fi
        else
            echo "NOTICE ($my_name): No configuration file specified, configuration will be saved to \"$config_filename_out\"" >&2
        fi
    fi
fi

# Parse .gitignore and populate gitignore_exclude and gitignore_include if enabled
if [[ "$use_gitignore" = true ]]; then
    parse_gitignore
fi

# Remove duplicates from exclusion and inclusion lists
remove_duplicates dir_excludes
remove_duplicates file_excludes
remove_duplicates pattern_excludes
remove_duplicates file_includes
remove_duplicates gitignore_exclude
remove_duplicates gitignore_include
remove_duplicates settings_modes

# Truncate the output file only if not in dry_run
if [[ "$dry_run" != true ]]; then
    : > "$output_filename"
else
    echo "Dry run: Skipping truncation of $output_filename" >&2
fi

# After truncating, handle the settings_modes to include info at the top
if [[ ${#settings_modes[@]} -gt 0 ]]; then
    set_env_vars
    display_settings settings_modes
fi

# Debug  Show final directory exclusions
if [[ $debug_level -gt 1 ]]; then
    echo "DEBUG ($my_name): Final directory exclusions: ${dir_excludes[*]}" >&2
fi

# Generate file tree markdown
generate_filetree "$output_filename" "${dir_excludes[@]}"

# Build the file list
declare -a final_files
build_file_list final_files file_includes file_excludes dir_excludes pattern_excludes

# Debug  Show final files to be processed
if [[ $debug_level -gt 3 ]]; then
    echo "DEBUG ($my_name): Final files to process:" >&2
    for f in "${final_files[@]}"; do
        printf "  \"$f\"" >&2
    done
fi

# Process the files and generate markdown
process_files "$output_filename" final_files
