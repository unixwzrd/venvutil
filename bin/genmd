#!/usr/local/bin/bash
#
# genmd - Combined source code markdown generator.
#
# `genmd` is a versatile Bash script designed to generate comprehensive Markdown documentation
# from your source code files. It scans directories, includes or excludes files based on
# specified patterns, and consolidates the content into a structured Markdown file.
# Additionally, it can generate a visual directory structure and manage configurations through
# dedicated files.
#
# Usage:
#     genmd [options]
#
# Options:
#     -e, --exclude [patterns]  Exclude directories matching the given patterns.
#                               Multiple patterns can be separated by '|' or spaces.
#
#     -f, --file [patterns]     Exclude files matching the given patterns.
#                               Multiple patterns can be separated by '|' or spaces.
#
#     -p, --pattern [patterns]  Exclude additional patterns matching the given strings.
#                               Multiple patterns can be separated by '|' or spaces.
#
#     -i, --include [patterns]  Include files matching the given patterns.
#                               Multiple patterns can be separated by '|' or spaces.
#
#     -o, --output [filename]   Output file (default: combined_source.md)
#
#     -L, --follow-links        Follow symbolic links when scanning directories.
#                               By default, genmd does not follow symbolic links.
#
#     -c, --config [filename]   Load configuration from a .grc file.
#                               If the filename does not end with .grc, it will be
#                               appended. The file will be created if it does not exist.
#
#     -s, --settings [modes]    Show settings. Modes can be:
#                               info    Show current settings
#                               cfg     Write to configuration file
#                               md      Include settings in markdown output
#                               env     Output settings as environment variables
#                               all     Perform info, md, and env actions
#
#     -n, --dry-run             Do not write the output file; print the files to be processed.
#
#     -g, --no-gitignore        Disable integration with .gitignore patterns.
#                               By default, genmd uses patterns from .gitignore to exclude files
#                               and directories. Use this flag to disable this behavior.
#
#     -C, --no-config           Run without sourcing the .grc configuration file.
#                               This allows you to execute genmd using only the provided
#                               command-line options and .gitignore patterns (if enabled).
#
#     -b, --remove-blanks       Optionally remove all blank lines and strip trailing spaces from
#                               each files.
#
#     -l, --line-numbers        Optionally add line numbers to each file using 'nl -n'rn''.
#
#     -z, --compress [tool]     Optionally compress the final output using the specified
#                               compression utility (e.g., gzip, xz, bzip2). The compressed file
#                               will be named as 'output.md.<extension>'.
#
#     -t, --tokens              Give a token count for the output.
#
#     -d, --debug [level]       Set debug level (0-60)
#                                   1:  DEBUG9
#                                   2:  DEBUG8
#                                   3:  DEBUG7
#                                   4:  DEBUG6
#                                   5:  DEBUG5
#                                   6:  DEBUG4
#                                   7:  DEBUG3
#                                   8:  DEBUG2
#                                   9:  DEBUG1
#                                   10: DEBUG
#                                   20: INFO
#                                   30: WARNING
#                                   40: ERROR
#                                   50: CRITICAL
#                                   99: SILENT
#
#     -h, --help                Show this help message
#
#
# Description:
#       The genmd script generates markdown from the files in the specified directory,
#       excluding files and directories based on provided patterns. It outputs:
#       - Project filesystem directory structure
#       - Source code in a single markdown file for all included files.
#       - Excluded files are omitted based on exclusion patterns.
#       - Configuration file will be read if the `-c` option is used, and it assumes .grc is the
#         file extension and the file is in the GENMD_BASE/utils/etc directory.
#       - Configuration file will be written if -o is used and will be placed in the
#         GENMD_BASE/utils/etc directory and will have the same name as the output file with
#         .grc appended.
#       - All exit codes are POSIX exit codes.
#
#       - Will use .gitignore patterns by default unless -g is used to reduce redundancy in your
#         `.grc` files.
#
# Examples:
#       genmd -e "node_modules|dist" -f "*.log *.tmp"  -i "*css *.js" -s "info,md" \
#             -o project_overview.md
#       genmd --exclude "node_modules|dist" --file "*.log *.tmp" --include "info" --dry-run
#       genmd -s info,md -d 2
#
# Environment:
#     GENMD_BASE: The base directory to search for files in.
#     GENMD_DIR_EXCLUDES: A default list of directory patterns to exclude from the generated
#                        markdown.
#     GENMD_FILE_EXCLUDES: A default list of file patterns to exclude from the generated markdown.
#     GENMD_PATTERN_EXCLUDES: A default list of additional patterns to exclude from the generated
#                            markdown.
#     GENMD_FILE_INCLUDES: A default list of file patterns to include in the generated markdown.
#     PAGER: The pager to use for output, defaults to `less -R`
#
# Files and directories:
#     Files are located in the GENMD_BASE directory.
#     - utils/etc/genmd.grc: Default configuration file.
#     - utils/etc: Default directory for configuration files.
#     - utils/output: Default directory for output files.
#
# Dependencies:
#     - bash 4.0 or higher
#     - filetree, located in this repository
#         https://github.com/unixwzrd/venvutil
#     - filetree requires the Rich Python library.
#
# Author:
#     Michael Sullivan <unixwzrd@unixwzrd.ai>
#         https://unixwzrd.ai/
#         https://github.com/unixwzrd
#
# License:
#     Apache License, Version 2.0
#

# Ensure the script exits on error and treats unset variables as errors
set -euo pipefail

# Get the base directory
# Determine the real path of the script
[ -L "${BASH_SOURCE[0]}" ] && THIS_SCRIPT=$(readlink -f "${BASH_SOURCE[0]}") || THIS_SCRIPT="${BASH_SOURCE[0]}"
# shellcheck disable=SC2034
MY_NAME=$(basename "${THIS_SCRIPT}")
# Check for Bash version 4+
if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    echo "ERROR ($MY_NAME): genmd requires Bash version 4 or higher." >&2
    exit 75     # (EPROGMISMATCH: 75): Program version wrong
fi

__VENV_BIN="$(dirname "${THIS_SCRIPT}")"
__VENV_BASE="$(dirname "${__VENV_BIN}")"
__VENV_INCLUDE="${__VENV_BASE}/bin/shinclude"

# shellcheck source=/dev/null
source "${__VENV_INCLUDE}/venvutil_lib.sh" || true

#Make sure our associated utilities are in the path
export PATH="${__VENV_BIN}:${PATH}"
# Get the base directory for the script
GENMD_BASE="${GENMD_BASE:-${BASE_DIR:-"."}}"
log_message "INFO" "Using base directory - $GENMD_BASE"

PAGER="${PAGER:-less -R}"

# Declare arrays
# Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. SC2206
# shellcheck disable=SC2206
declare -g -a dir_excludes=${GENMD_DIR_EXCLUDES:-( ".git" "tmp" "log" "__pycache__" ".vscode" )}
# shellcheck disable=SC2206,SC2034
declare -g -a file_excludes=${GENMD_FILE_EXCLUDES:-( "*.ico" "*.svg" "*.png" "*.pdf" "*.jpg" "*.htaccess" "*.webp" "*.jekyll" ".DS_Store" "*.JPG" "*.pdf" )}
# shellcheck disable=SC2206
declare -g -a pattern_excludes=${GENMD_PATTERN_EXCLUDES:-()}
# shellcheck disable=SC2206,SC2034
declare -g -a file_includes=${GENMD_FILE_INCLUDES:-()}
declare -g -a gitignore_excludes=()
declare -g -a gitignore_includes=()


# Mapping of short options to their respective target arrays
declare -g -A option_variable=(
    ["e"]="dir_excludes"
    ["f"]="file_excludes"
    ["i"]="file_includes"
    ["p"]="pattern_excludes"
    ["s"]="settings_modes"
)

# Define a list of variables to save in the configuration file
# This is also the order in which they will appear in the config file
# and the order in which they will appear in the md file output.
declare -g -a config_variables=(
    "create_date"
    "dir_excludes"
    "file_excludes"
    "pattern_excludes"
    "file_includes"
    "GENMD_BASE"
    "output_filename"
    "settings_modes"
    "dry_run"
    "debug_level"
    "use_gitignore"
    "follow_links"
    "remove_blanks"
    "add_line_numbers"
    "compress"
    "compression_tool"
    "count_tokens"
    "token_count"
)

# Define a list of actions for each config variable based on whether to
# merge or set from the config file or the command line.
# the precedent will be from the command line for some or from the
# config file for others, some may come from the environment variables
# and some may come from the config file or the command line.
# shellcheck disable=SC2034
declare -g -A config_variable_action=(
    ["GENMD_BASE"]="config"       # Set config file will override the environment variable
    ["add_line_numbers"]="set"    # Command line overrides all settings and preserved
    ["compress"]="set"            # Command line overrides all settings and preserved
    ["compression_tool"]="set"    # Command line overrides all settings and preserved
    ["count_tokens"]="set"        # Command line overrides all settings and preserved
    ["create_date"]="set"         # Command line overrides all settings and preserved
    ["debug_level"]="set"         # Command line overrides all settings and preserved
    ["dir_excludes"]="merge"      # Merge all sources.
    ["dry_run"]="set"         # Command not preserved, but set from command line
    ["file_excludes"]="merge"     # Merge all sources.
    ["file_includes"]="merge"     # Merge all sources.
    ["follow_links"]="set"        # Command line overrides all settings and preserved
    ["output_filename"]="set"     # Command line overrides all settings
    ["pattern_excludes"]="merge"  # Merge all sources.
    ["remove_blanks"]="set"       # Command line overrides all settings and preserved
    ["settings_modes"]="set"      # Command line overrides all settings
    ["token_count"]="discard"     # Read-only, cannot be set from command line
    ["use_gitignore"]="set"       # Command line overrides all settings and preserved
)

# Set default values for command line options.
# Define file defaults.
declare -g add_line_numbers=false
declare -g compress=false
declare -g compression_tool="gzip"
declare -g config_dir="$GENMD_BASE/utils/etc"
declare -g count_tokens=false
#  shellcheck disable=SC2034,SC2155
declare -g create_date=$(date '+%Y-%m-%d %H:%M:%S')
declare -g debug_level=20
declare -g default_filename="combined_source"        # Default output filename
declare -g dry_run=false
declare -g follow_links=""
declare -g output_dir="$GENMD_BASE/utils/output"
declare -g remove_blanks=false
declare -g settings_modes=( "md" "cfg" )
declare -g skip_config=false                        # Set to true to skip loading config file
declare -g specified_config=""
declare -g specified_output=""
declare -g token_count=0
declare -g use_gitignore=true


# Function to handle pattern-based array options from command line.
# Set the values of an array variable from a command line option.
#
#   Args:
#       $1: The name of the option (e.g. "file_excludes")
#       $2: The value of the option from the command line. This can be a string or a
#           pattern with the | character.
#       $3: The name of the target variable to be set.
#
# Returns:
#   None
#
set_option_value() {
    local opt_name="$1"
    shift
    local target_variable="$1"
    shift
    local opt_value=("$@")

    log_message "DEBUG3" "*** Setting command line options for $opt_name to \"$opt_value\""
    if [[ -n "$opt_value" && ! "$opt_value" =~ ^- ]]; then
        log_message "DEBUG1" "Load ${target_variable} with ${opt_name} values: ${opt_value}"
        update_variable config_variable_action "$target_variable" opt_value
    else
        display_help "ERROR ($MY_NAME): -$opt_name requires a pattern string."
    fi
}


# sanitize_patterns - Sanitizes a string by retaining only alphanumerics, underscores, dots, dashes,
# and spaces.
#
# Usage:
#   sanitized_string=$(sanitize_patterns "$input")
#
# Examples:
#   $ sanitize_patterns "regex[0-9]._* "
#   regex[0-9].*
#
# Returns:
#   The sanitized string.
#
sanitize_patterns() {
    local input="$*"
    # Retain only alphanumerics, underscores, dots, dashes, and spaces
    cleanstring=${input//[^a-zA-Z0-9-_.*? ]/}
    log_message "DEBUG" "Dirty pattern: $input"
    log_message "DEBUG" "Clean pattern: $cleanstring"
    echo "$cleanstring"
}


# parse_gitignore - Parse a .gitignore file for patterns to exclude/include
#
# Description:
#   Reads a .gitignore file and parses its contents to populate the
#   `gitignore_excludes` and `gitignore_includes` arrays. The function will
#   skip empty lines, comment lines, and regular exclusion patterns. If the
#   file does not exist, the function will log a message and exit.
#
# Parameters:
#   None
#
# Returns:
#   None
#
# Scope:
#   Global. Modifies the global arrays `gitignore_excludes` and `gitignore_includes`.
#
# Input:
#   Reads .gitignore file
#
# Output:
#   None
#
parse_gitignore() {
    local gitignore_file="$GENMD_BASE/.gitignore"

    if [[ -f "$gitignore_file" ]]; then
        log_message "INFO" "Parsing .gitignore file: $gitignore_file"

        while IFS= read -r line || [[ -n "$line" ]]; do
            # Trim leading and trailing whitespace
            line="$(echo "$line" | sed -e 's/[[:space:]].*$//')"
            [[ -z "$line" || "$line" =~ ^# ]] && continue


            if [[ "$line" =~ ^! ]]; then
                pattern="${line:1}"
                # Optionally anchor explicit includes too (for consistency)
                [[ "$pattern" == *.* ]] && pattern="${pattern}$"
                gitignore_includes+=("$pattern")
                log_message "DEBUG1" "Parsed .gitignore include pattern: $pattern"
                continue
            fi

            # Anchor excludes
            if [[ "$line" == *.* ]]; then
                line="${line}$"
            fi
            gitignore_excludes+=("$line")
            log_message "DEBUG1" "Parsed .gitignore exclude pattern: $line"

        done < "$gitignore_file"
    else
        log_message "INFO" "No .gitignore file found at $gitignore_file. Skipping .gitignore integration."
    fi
}


# load_config - Function to load configuration from a .grc file
#
# Description:
#   Loads a configuration file and assigns the variables using the config_variable_action array.
#
#   The config_variable_action array is used to determine how to assign the values from the config file:
#   - merge: the value will be added to the variable
#   - set: set the variable from the command line or defaults
#   - config: set the variable from the config file
#   - discard: the value not be preserved in the config file
#
# Parameters:
#   $1: The path to the configuration file to load.
#   $2: The name of the config variable to load.
#
#  TODO move this function to the config_lib.sh
#
load_config() {
    local config_file="$1"

    if [ "$skip_config" = true ]; then
        log_message "INFO" "Skipping config file loading."
        return 0
    fi

    if [[ -e "$config_file" ]]; then
        local tmp_debug_level=$debug_level
        # shellcheck source=/dev/null
        source "$config_file"
        debug_level=${tmp_debug_level}
    fi
}

# load_config_file - Function to determine and load configuration based on output and config file specifications
#
# Description:
#   This function determines which configuration file to load based on the output and config file specifications:
#   - If the output file is specified and the config file is specified, the specified config file is loaded.
#   - If the output file is specified but the config file is not specified, a new config file is created with the name of the output file.
#   - If the output file is not specified but the config file is specified, the specified config file is loaded.
#   - If neither the output file nor the config file is specified, the default config file is loaded.
#
# Parameters:
#   None.
#
load_config_file() {
    if [[ -n "$specified_output" && -n "$specified_config" ]]; then
        # Scenario: Output file specified and config file specified
        config_filename_in="${config_dir}/${specified_config}.grc"
        config_filename_out="$config_filename_in"
        output_filename="${output_dir}/${specified_config}.md"

        if [[ -e "$config_filename_in" ]]; then
            load_config "$config_filename_in"
        else
            log_message "WARNING" "Specified configuration file \"$config_filename_in\" creating new config file."
            check_directory "$(dirname "$config_filename_in")"
            touch "$config_filename_in"
        fi
    elif [[ -n "$specified_output" && -z "$specified_config" ]]; then
        # Scenario: Output file specified, config file not specified
        config_filename_in="${config_dir}/${specified_output}.grc"
        config_filename_out="${config_dir}/${specified_output}.grc"
        output_filename="${output_dir}/${specified_output}.md"

        if [[ -e "$config_filename_in" ]]; then
            load_config "$config_filename_in"
        else
            log_message "INFO" "No configuration file found for output \"$specified_output\", a new one will be created."
        fi
    elif [[ -z "$specified_output" && -n "$specified_config" ]]; then
        # Scenario: Output file not specified, config file specified
        config_filename_in="${config_dir}/${specified_config}.grc"
        config_filename_out="$config_filename_in"
        output_filename="${output_dir}/${specified_config}.md"

        if [[ -e "$config_filename_in" ]]; then
            load_config "$config_filename_in"
        else
            log_message "WARNING" "Specified configuration file \"$config_filename_in\" creating new config file."
            check_directory "$(dirname "$config_filename_in")"
            touch "$config_filename_in"
        fi
    else
        # Scenario: Neither output file nor config file specified
        config_filename_in="${config_dir}/${default_filename}.grc"
        config_filename_out="$config_filename_in"
        output_filename="${output_dir}/${default_filename}.md"

        if [[ -e "$config_filename_in" ]]; then
            load_config "$config_filename_in"
        else
            log_message "WARNING" "Specified configuration file \"$config_filename_in\" creating new config file."
            check_directory "$(dirname "$config_filename_in")"
            touch "$config_filename_in"
        fi
    fi
}

# Function to display a short help message
#
# ## Description
# - **Purpose**:
#   - Displays a help message extracted from the script file.
# - **Usage**:
#   - `display_help <message>`
# - **Input Parameters**:
#   - `message`: A brief introduction or message to be included in the help text.
# - **Output**:
#   - Displays the help text in a paginated format using the specified pager or defaults to `cat`.
# - **Exceptions**:
#   - Calls `errno_exit` with an error code of 22 if an invalid argument is encountered.
#
display_help() {
    # Initialize a variable to hold the help text
    local message=$1
    local help_text=""

    # Read the script file line by line
    help_text+="$message"$'\n\n'
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip the shebang line
        if [[ "$line" =~ ^#!/ ]]; then
            continue
        fi
        if [[ "$line" =~ ^$ ]]; then
            break
        fi
        if [[ "$line" =~ ^\#$ ]]; then
            help_text+=$'\n'
            continue
        fi
        if [[ "$line" =~ ^\#[[:space:]]* ]]; then
            help_text+="${line//\# /}"$'\n'
            continue
        fi
    done < "$0"

    printf "%s" "$help_text" | ${PAGER:-/bin/cat}
    errno_exit 22     # (EINVAL: 22): Invalid argument
}


build_regex() {
    local array_name="$1"
    local regex=""
    local pattern escaped subregex
    local -n arr_ref="$array_name"  # Create nameref so we can use the array directly

    # If the array is empty, return empty.
    if (( ${#arr_ref[@]} == 0 )); then
        log_message "INFO" "No patterns found for in build_regex $array_name"
        return
    fi

    for pattern in "${arr_ref[@]}"; do
        # Skip empty patterns so that they do not contribute empty alternatives.
        if [[ -z "$pattern" ]]; then
            log_messsage "INFO" "Found n empty pattern for ${array_name}"
            continue
        fi
        # Escape common regex metacharacters.
        escaped=$(printf '%s' "$pattern" | sed -E 's/([.^$+?(){}|\[\]\\])/\\\1/g')
        # Optionally convert asterisks to ".*"
        escaped="${escaped//\./\\.}"
        escaped="${escaped/#\*/.*}"
        # escaped="(^|/)$escaped(/|$)"
        if [ -z "$regex" ]; then
            regex="$escaped"
        else
            regex="$regex|$escaped"
        fi
    done
    echo "$regex"
}

# build_file_list() - builds the final file list from excludes and includes.
# It expects:
#   $1 - a name reference for the output array
#   $2..$n - names of arrays (each array should be named with a suffix "_excludes" or "_includes")
build_file_list() {
    local -n final_files_ref=$1
    shift

    local composite_exclude=""
    local composite_include=""
    local regex pattern_list

    # Change to the base directory.
    cd "$GENMD_BASE" || errno_exit "ENOTDIR" "Cannot cd to $GENMD_BASE"

    # Loop over every array name passed.
    for pattern_list in "$@"; do
        local -n composite_ref="$pattern_list"
        if [[ ${#composite_ref[@]} == 0 ]]; then
            log_message "WARN" "No patterns found for $pattern_list"
            continue
        else
            composite_list=$(build_regex "$pattern_list")
            case "$pattern_list" in
                *excludes)
                    if [[ -z "$composite_exclude" ]]; then
                        composite_exclude="${composite_list}"
                    else
                        composite_exclude="${composite_exclude}|${composite_list}"
                    fi
                    ;;
                *includes)
                    if [[ -z "$composite_include" ]]; then
                        composite_include="${composite_list}"
                    else
                        composite_include="${composite_include}|${composite_list}"
                    fi
                    ;;
                *)
                    errno_warn "EINVAL" "Warning: $pattern_list does not match expected naming (must end with _excludes or _includes)"
                    ;;
            esac
        fi
    done

    echo
    log_message "INFO" "********** Composite EXCLUDE: \"${composite_exclude}\""
    echo
    log_message "INFO" "********** Composite INCLUDE: \"${composite_include}\""
    echo

    mapfile -t files < <(
        find ${follow_links:-} . -type f \
            | grep -Ev "${composite_exclude:-}" \
            | grep -E  "${composite_include:-}" \
            | sort
        )

    final_files_ref=("${files[@]}")
}

# Function to generate markdown for a source file.
#
# Args:
#   $1 (string): The source file to generate markdown for.
#   $2 (string): The type of markdown to generate.
#
# Returns:
#   None
#
generate_markdown() {
    local source_file="$1"
    local markdown_type="$2"

    if [[ "$dry_run" = true ]]; then
        log_message "INFO" "Dry run: Would generate markdown type '$markdown_type' for: $source_file"
        return
    fi

    log_message "INFO" "Generating markdown for: $source_file"

    # Create a temporary file for processing
    local temp_file
    temp_file=$(mktemp)

    # Optionally remove blank lines and strip trailing spaces
    if [[ "$remove_blanks" = true ]]; then
        # Remove blank lines and lines with only spaces, then strip trailing spaces
        sed '/^\s*$/d;s/[[:space:]]\+$//' "$source_file" > "$temp_file"
    else
        cp "$source_file" "$temp_file"
    fi

    # Optionally add line numbers
    if [[ "$add_line_numbers" = true ]]; then
        nl -n'rn' -b'a' "$temp_file" > "${temp_file}.numbered"
        mv "${temp_file}.numbered" "$temp_file"
    fi

    {
        printf "\n\n## Filename ==>  %s\n\`\`\`%s\n" "$source_file" "$markdown_type"
        # Escape backticks for markdown
        cat < "$temp_file" | sed "s/\`\`\`/\\\\\`\\\\\`\\\\\`/g"
        printf "\n\`\`\`\n"
    } >> "$output_filename"

    # Remove the temporary file
    rm "$temp_file"
}

# Function to generate the filetree markdown.
#
# Args:
#   $1 (string): The output filename.
#   $2 (array): The list of excluded directories.
#
# Returns:
#   None
#
generate_filetree() {
    local output_filename=$1
    local -n include_list_ref=$2
    shift; shift
    local exclude_list="$*"

    include_string=$(sanitize_patterns "${include_list_ref[@]}")
    exclude_string=$(sanitize_patterns "${exclude_list[@]}")

    if ! command -v filetree >/dev/null 2>&1; then
        log_message "ERROR" "'filetree' command not found. Please install it or use an alternative."
        log_message "ERROR" "It should have been included with this script and it should be in your \$PATH."
        exit 2  # (ENOENT: 2): No such file or directory
    fi

    if [[ "$dry_run" = true ]]; then
        log_message "INFO" "Dry run: Generating directory and file structure."
        # shellcheck disable=SC2086
        filetree -l $debug_level  -i "${include_string}" -e tmp .git "${exclude_string[@]}"
        return
    fi

    log_message "INFO" "Generating directory and file structure, including: ${include_string}, excluding: ${exclude_string}"

    {
        printf "\n\n## Project filesystem directory structure\n\`\`\`text\n"
        # Double quote to prevent globbing and word splitting.shellcheckSC2086
        # shellcheck disable=SC2086
        echo filetree -l $debug_level -i "${include_string}" -e tmp .git "${exclude_string}"
        # shellcheck disable=SC2086
        filetree -l $debug_level -i "${include_string}" -e tmp .git "${exclude_string}"
        printf "\n\`\`\`\n"
    } >> "$output_filename"
}

# Function to get the file type using the `file` command.
#
# Args:
#   $1 (string): The output filename.
#   $2 (array): A reference to the final files array.
#
# Returns:
#   None
#
process_files() {
    local output_filename="$1"
    local -n files_ref="$2"
    # Iterate over files and generate markdown
    for file in "${files_ref[@]}"; do
        # Determine file type based on extension
        local file_type
        local file_description
        file_description=$(file -b "$file")
        case "$file_description" in
            *Bourne-Again*) file_type="bash";;
            *Bourne*) file_type="sh";;
            *HTML*) file_type="html";;
            *html\ *) file_type="html";;
            *JSON*) file_type="json";;
            *JavaScript*) file_type="javascript";;
            *Java*) file_type="java";;
            *Markdown*) file_type="markdown";;
            *PHP*) file_type="php";;
            *[Pp]erl*) file_type="perl";;
            *Python*) file_type="python";;
            *[Rr]uby*) file_type="ruby";;
            *SASS*) file_type="sass";;
            *SCSS*) file_type="scss";;
            *CSS*) file_type="css";;
            *shell*) file_type="sh";;
            *Shell*) file_type="bash";;
            *[Tt]ext*)
                # if teh description from the file command returns a match on .txt or .text,
                # check the suffix of the file and if it's valid, like js, scss, md, html,
                # set filetype to the extension of the file
                local file_suffix="${file##*.}"
                case "$file_suffix" in
                    js) file_type="javascript";;
                    scss) file_type="scss";;
                    md) file_type="markdown";;
                    html) file_type="html";;
                    *) file_type="text";;
                esac
            ;;
            *YAML*) file_type="yaml";;
            *) file_type="unknown";;
        esac
        if [[ "$file_type" = "unknown" ]]; then
            log_message "INFO" "Skipping unknown $file_description type: \"$file\""
            continue
        fi
        log_message DEBUG2 "File description: $file_description Converts to: $file_type"
        generate_markdown "$file" "$file_type"
    done
}

# compress_output-  Function to compress the final output
#
# Compress the final output using the specified compression tool if it exists.
#
# Args:
#     $1 (string): The filename of the output to compress.
#
# Returns:
#     0: Success
#     1: Failure to compress
#
compress_output() {
    local output_filename="$1"

    if [[ "$compress" = true ]]; then
        if ! command -v "$compression_tool" &>/dev/null; then
            log_message "WARNING" "Compression tool $compression_tool not found skipping compression"
            return 1
        fi
        case "$compression_tool" in
            gzip) extension="gz";;
            bzip2) extension="bz2";;
            xz) extension="xz";;
            *) log_message "WARNING" "Compression tool $compression_tool not supported skipping compression"
                return 1;;
        esac

        $compression_tool - < "$output_filename" > "${output_filename}.${extension}"
        log_message "INFO" "Final compressed output is ${output_filename}.${extension}"
    fi
}

# Function to generate the settings section for the document
#
# Args:
#     $1 (string): The output filename to write to
#     $2 (array): Array of modes for displaying settings
#
# Returns:
#     None
generate_settings() {
    local output_file=$1
    local -n modes=$2

    if [[ "$dry_run" = true ]]; then
        log_message "INFO" "Dry run: Would generate settings section to $output_file"
        return
    fi

    if [[ ${#modes[@]} -gt 0 ]]; then
        if [[ " ${modes[*]} " =~ " all " ]]; then
            modes=("info" "md" "cfg" "env")
        fi

        for mode in "${modes[@]}"; do
            case "$mode" in
                info)
                    log_message "INFO" "genmd current settings:"
                    dump_config -s config_variables | sed 's/=/: /'
                    ;;
                md)
                    {
                        echo "## genmd Settings"
                        echo ""
                        echo "| Variable               | Value                                                                 |"
                        echo "|------------------------|-----------------------------------------------------------------------|"
                        dump_config -s config_variables | sed 's/^\(.*\)=\(.*\)$/|\1|\2|/'
                    } >> "$output_file"
                    ;;
                cfg)
                    check_directory "$(dirname "$config_filename_out")"
                    dump_config -s -o "$config_filename_out" config_variables
                    log_message "INFO" "Configuration saved to $config_filename_out"
                    ;;
                env)
                    {
                        echo ""
                        echo "## genmd Environment Variables"
                        echo ""
                        dump_config -s config_variables
                        echo ""
                    } > "${GENMD_BASE}/genmd_env.sh"
                    ;;
                *)
                    log_message "WARN" "Unknown mode '$mode' for --settings"
                    ;;
            esac
        done
    fi
}

# Main execution begins here
main() {
    # After determining and loading configuration
    # Process the document with token counting

    # If it's a dry run, we could redirect output to /dev/null
    local output_target="$output_filename"
    if [[ "$dry_run" = true ]]; then
        log_message "INFO" "Dry run: Output will be discarded"
        output_target="/dev/null"
    fi

    # Create temporary files for the multi-step process
    local temp_header=$(mktemp)
    local temp_body=$(mktemp)

    log_message "DEBUG" "Created temporary files: header=$temp_header, body=$temp_body"

    # Step 1: Generate the header with initial settings (no token count yet)
    # Truncate the header file
    : > "$temp_header"

    # Generate the settings section to the header
    if [[ ${#settings_modes[@]} -gt 0 ]]; then
        generate_settings "$temp_header" settings_modes
    fi

    # Step 2: Process the body content
    # Truncate the body file
    : > "$temp_body"

    # Generate file tree markdown
    # Argument mixes string and array. Use * or separate argument.
    # shellcheck disable=SC2145
    generate_filetree "$temp_body" file_includes "${dir_excludes[@]}" "${pattern_excludes[@]}" "${file_excludes[@]}"

    # Build the file list
    build_file_list final_files dir_excludes \
                    pattern_excludes gitignore_excludes \
                    gitignore_includes file_excludes \
                    file_includes

    # Debug: Show final files to be processed
    {
        printf "\n## Files included in final output\n"
        # shellcheck disable=SC2154,SC2068
        for f in "${final_files[@]}"; do
            printf -- "- %s\n" "$f"
        done
        printf "\n---\n"
    } >> "$temp_body"

    # Process the files and generate markdown
    process_files "$temp_body" final_files

    # Step 3: Calculate token count by combining files temporarily
    if [[ "$count_tokens" = true ]]; then
        local temp_combined=$(mktemp)
        cat "$temp_header" "$temp_body" > "$temp_combined"
        token_count=$(tokencount -c -f "$temp_combined" 2>/dev/null)
        log_message "INFO" "Document token count: $token_count"
        rm -f "$temp_combined"

        # Step 4: Regenerate the header with updated token count
        # Only regenerate the header if we're counting tokens
        # Truncate the header file
        : > "$temp_header"

        # Only use "md" mode for the second pass to prevent running cfg/env operations twice
        local md_mode=("md")
        generate_settings "$temp_header" md_mode
    fi

    # Step 5: Create the final output file
    # Truncate the output file
    : > "$output_target"
    # Combine header and body
    cat "$temp_header" "$temp_body" > "$output_target"

    # Clean up temporary files
    rm -f "$temp_header" "$temp_body"

    # Step 6: Compress the final output if compression is enabled
    if [[ "$compress" = true && "$dry_run" != true ]]; then
        compress_output "${output_filename}"
    fi
}

# Processing begins here with loading config file if it exists and command line options

# Process command-line options using getopts
# Reset OPTIND in case getopts has been used previously
OPTIND=1
while getopts ":d:he:f:i:p:o:c:s:nvgCbLltz:-:" opt; do
    case "$opt" in
        # Short options
        d)
            if [[ "$OPTARG" -ge 1 && "$OPTARG" -le 99 ]]; then
                debug_level="$OPTARG"
                if [[ "$debug_level" -eq 1 ]]; then
                    set -x
                fi
            else
                display_help "ERROR ($MY_NAME): Debug level must be between 10 and 99."
            fi
            ;;
        e|f|i|p|s)
            IFS=' ' read -r -a arr <<< "$OPTARG"
            set_option_value "$opt" "${option_variable[$opt]}" "${arr[@]}"
            ;;
        o)
            value="${OPTARG#*=}"
            specified_output="$(basename "$value" .md)"
            ;;
        c)
            value="${OPTARG#*=}"
            specified_config="$(basename "$value" .grc)"
            ;;
        n)
            dry_run=true
            ;;
        g)
            use_gitignore=false  # Disable gitignore integration
            ;;
        L)
            follow_links="-L"    # Follow symlinks
            ;;
        C)
            skip_config=true     # New option to skip config files
            ;;
        b)
            remove_blanks=true
            ;;
        l)
            add_line_numbers=true
            ;;
        t)
            count_tokens=true
            ;;
        z)
            compress=true
            compression_tool="$OPTARG"
            # Validate compression tool
            case "$compression_tool" in
                gzip|xz|bzip2)
                    ;;
                *)
                    log_message "WARNING" "Unsupported compression tool '$compression_tool', using gzip for compression."
                    ;;
            esac
            ;;
        h)
            display_help ""
            ;;
        -)
            # Handle long options manually
            case "${OPTARG}" in
                debug=*)
                    if [[ "$OPTARG" -ge 1 && "0$OPTARG" -le 99 ]]; then
                        debug_level="$OPTARG"
                        if [[ "$debug_level" -eq 1 ]]; then
                            set -x
                        fi
                    else
                        display_help "ERROR ($MY_NAME): Debug level must be between 0 and 99."
                    fi
                    ;;
                help)
                    display_help ""
                    ;;
                exclude=*)
                    set_option_value "exclude" dir_excludes "${OPTARG#*=}"
                    ;;
                file=*)
                    set_option_value "file" file_excludes "${OPTARG#*=}"
                    ;;
                include=*)
                    set_option_value "include" file_includes "${OPTARG#*=}"
                    ;;
                pattern=*)
                    set_option_value "pattern" pattern_excludes "${OPTARG#*=}"
                    ;;
                output=*)
                    value="${OPTARG#*=}"
                    specified_output="$(basename "$value" .md)"
                    ;;
                config=*)
                    value="${OPTARG#*=}"
                    specified_config="$(basename "$value" .grc)"
                    ;;
                settings=*)
                    set_option_value "pattern" "${OPTARG#*=}" settings_modes
                    ;;
                no-gitignore)
                    use_gitignore=false
                    ;;
                follow-links)
                    follow_links="-L"
                    ;;
                no-config)
                    skip_config=true
                    ;;
                remove-blanks)
                    remove_blanks=true
                    ;;
                line-numbers)
                    add_line_numbers=true
                    ;;
                tokens)
                    count_tokens=true
                    ;;
                compress=*)
                    compress=true
                    compression_tool="${OPTARG#*=}"
                    # Validate compression tool
                    case "$compression_tool" in
                        gzip|xz|bzip2)
                            ;;
                        *)
                            display_help "ERROR ($MY_NAME): Unsupported compression tool '$compression_tool'. Supported tools are gzip, xz, bzip2."
                            ;;
                    esac
                    ;;
                *)
                    display_help "ERROR ($MY_NAME): Unknown option '--${OPTARG}'"
                    ;;
            esac
            ;;
        \?)
            display_help "ERROR ($MY_NAME): Invalid option '-$OPTARG'"
            ;;
        :)
            display_help "ERROR ($MY_NAME): Option '-$OPTARG' requires an argument."
            ;;
        ?)
            display_help "ERROR ($MY_NAME): Unknown option '-$OPTARG'"
            ;;
    esac
done

# Shift off the options and optional --
shift $((OPTIND -1))

# Determine and load configuration based on output and config file specifications
load_config_file

# Ensure necessary directories exist
check_directory "$output_dir"
check_directory "$config_dir"

# Parse .gitignore and populate gitignore_excludes and gitignore_includes if enabled
if [[ "$use_gitignore" = true ]]; then
    parse_gitignore
fi

# Remove duplicates from exclusion and inclusion lists
remove_duplicates dir_excludes
remove_duplicates file_excludes
remove_duplicates pattern_excludes
remove_duplicates gitignore_excludes
remove_duplicates gitignore_include
remove_duplicates file_includes
remove_duplicates settings_modes

# Debug: Show final directory exclusions
log_message "DEBUG1" "Final directory exclusions: ${dir_excludes[*]}"

# Execute the main process
main

# Display final information
log_message "INFO" "       Output file: $output_filename"
log_message "INFO" "Configuration file: $config_filename_out"
if [[ "$count_tokens" = true ]]; then
    log_message "INFO" "     Token count: $token_count"
fi