#!/usr/local/bin/bash
#
# genmd - Combined source code markdown generator.
#
# `genmd` is a versatile Bash script designed to generate comprehensive Markdown documentation
# from your source code files. It scans directories, includes or excludes files based on
# specified patterns, and consolidates the content into a structured Markdown file.
# Additionally, it can generate a visual directory structure and manage configurations through
# dedicated files.
#
# Usage:
#     genmd [options]
# 
# Options:
#     -d, --debug [level]       Set debug level (0-60)
#                                   1:  DEBUG9
#                                   2:  DEBUG8
#                                   3:  DEBUG7
#                                   4:  DEBUG6
#                                   5:  DEBUG5
#                                   6:  DEBUG4
#                                   7:  DEBUG3
#                                   8:  DEBUG2
#                                   9:  DEBUG1
#                                   10: DEBUG
#                                   20: INFO
#                                   30: WARNING
#                                   40: ERROR
#                                   50: CRITICAL
#                                   99: SILENT
#
#     -h, --help                Show this help message
# 
#     -e, --exclude [patterns]  Exclude directories matching the given patterns.
#                               Multiple patterns can be separated by '|' or spaces.
# 
#     -f, --file [patterns]     Exclude files matching the given patterns.
#                               Multiple patterns can be separated by '|' or spaces.
# 
#     -p, --pattern [patterns]  Exclude additional patterns matching the given strings.
#                               Multiple patterns can be separated by '|' or spaces.
# 
#     -i, --include [patterns]  Include files matching the given patterns.
#                               Multiple patterns can be separated by '|' or spaces.
# 
#     -o, --output [filename]   Output file (default: combined_source.md)
# 
#     -L, --follow-links        Follow symbolic links when scanning directories.
#                               By default, genmd does not follow symbolic links.
# 
#     -c, --config [filename]   Load configuration from a .grc file.
#                               If the filename does not end with .grc, it will be
#                               appended.
# 
#     -s, --settings [modes]    Show settings. Modes can be:
#                               info    Show current settings
#                               cfg     Write to configuration file
#                               md      Include settings in markdown output
#                               env     Output settings as environment variables
#                               all     Perform info, md, and env actions
# 
#     -n, --dry-run             Do not write the output file; print the files to be processed.
# 
#     -g, --no-gitignore        Disable integration with .gitignore patterns.
#                               By default, genmd uses patterns from .gitignore to exclude files
#                               and directories. Use this flag to disable this behavior.
# 
#     -C, --no-config           Run without sourcing the .grc configuration file.
#                               This allows you to execute genmd using only the provided
#                               command-line options and .gitignore patterns (if enabled).
# 
#     -b, --remove-blanks       Optionally remove all blank lines and strip trailing spaces from
#                               each files.
# 
#     -l, --line-numbers        Optionally add line numbers to each file using 'nl -n'rn''.
# 
#     -z, --compress [tool]     Optionally compress the final output using the specified
#                               compression utility (e.g., gzip, xz, bzip2). The compressed file
#                               will be named as 'output.md.<extension>'.
#
#     -t, --tokens              Give a token count for the output.
# 
# Description:
#       The genmd script generates markdown from the files in the specified directory,
#       excluding files and directories based on provided patterns. It outputs:
#       - Project filesystem directory structure
#       - Source code in a single markdown file for all included files.
#       - Excluded files are omitted based on exclusion patterns.
#       - Configuration file will be read if the `-c` option is used, and it assumes .grc is the 
#         file extension and the file is in the GENMD_BASE/utils/etc directory.
#       - Configuration file will be written if -o is used and will be placed in the
#         GENMD_BASE/utils/etc directory and will have the same name as the output file with
#         .grc appended.
#       - All exit codes are POSIX exit codes.
#   
#       - Will use .gitignore patterns by default unless -g is used to reduce redundancy in your
#         `.grc` files.
#
# Examples:
#       genmd -e "node_modules|dist" -f "*.log *.tmp"  -i "*css *.js" -s "info,md" \
#             -o project_overview.md
#       genmd --exclude "node_modules|dist" --file "*.log *.tmp" --include "info" --dry-run
#       genmd -s info,md -d 2
#
# Environment:
#     GENMD_BASE: The base directory to search for files in.
#     GENMD_DIR_EXCLUDES: A default list of directory patterns to exclude from the generated
#                        markdown.
#     GENMD_FILE_EXCLUDES: A default list of file patterns to exclude from the generated markdown.
#     GENMD_PATTERN_EXCLUDES: A default list of additional patterns to exclude from the generated
#                            markdown.
#     GENMD_FILE_INCLUDES: A default list of file patterns to include in the generated markdown.
#     PAGER: The pager to use for output, defaults to `less -R`
# 
# Files and directories:
#     Files are located in the GENMD_BASE directory.
#     - utils/etc/genmd.grc: Default configuration file.
#     - utils/etc: Default directory for configuration files.
#     - utils/output: Default directory for output files.
# 
# Dependencies:
#     - bash 4.0 or higher
#     - filetree, located in this repository
#         https://github.com/unixwzrd/venvutil
#     - filetree requires the Rich Python library. 
#     
# Author:
#     Michael Sullivan <unixwzrd@unixwzrd.ai>
#         https://unixwzrd.ai/
#         https://github.com/unixwzrd
# 
# License:
#     Apache License, Version 2.0
#

# Ensure the script exits on error and treats unset variables as errors
set -euo pipefail

# Get the base directory
# Determine the real path of the script
[ -L "${BASH_SOURCE[0]}" ] && THIS_SCRIPT=$(readlink -f "${BASH_SOURCE[0]}") || THIS_SCRIPT="${BASH_SOURCE[0]}"
# shellcheck disable=SC2034
MY_NAME=$(basename "${THIS_SCRIPT}")
# Check for Bash version 4+
if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    echo "ERROR ($MY_NAME): genmd requires Bash version 4 or higher." >&2
    exit 75     # (EPROGMISMATCH: 75): Program version wrong
fi

__VENV_BIN="$(dirname "${THIS_SCRIPT}")"
__VENV_BASE="$(dirname "${__VENV_BIN}")"
__VENV_INCLUDE="${__VENV_BASE}/bin/shinclude"

# shellcheck source=/dev/null
source "${__VENV_INCLUDE}/venvutil_lib.sh" || true

#Make sure our associated utilities are in the path
export PATH="${__VENV_BIN}:${PATH}"
# Get the base directory for the script
GENMD_BASE="${GENMD_BASE:-${BASE_DIR:-"."}}"
log_message "INFO" "Using base directory - $GENMD_BASE" 

PAGER="${PAGER:-less -R}"

# Declare arrays
# Quote to prevent word splitting/globbing, or split robustly with mapfile or read -a. SC2206
# shellcheck disable=SC2206
declare -g -a dir_excludes=(${GENMD_DIR_EXCLUDES:-( ".git" "tmp" "log" "__pycache__" ".vscode")})
# File_excludes appears unused. Verify use (or export if used externally).
# shellcheck disable=SC2206,SC2034
declare -g -a file_excludes=(${GENMD_FILE_EXCLUDES:-( "*.ico" "*.svg" "*.png" "*.pdf" "*.jpg" "*.htaccess" "*.webp" "*.jekyll" ".DS_Store" "*.JPG" "*.pdf" )})
# shellcheck disable=SC2206
declare -g -a pattern_excludes=(${GENMD_PATTERN_EXCLUDES:-""})
# shellcheck disable=SC2206,SC2034
declare -g -a file_includes=(${GENMD_FILE_INCLUDES:-""})
declare -g -a gitignore_exclude=()
declare -g -a gitignore_includes=()


# Mapping of short options to their respective target arrays
declare -g -A option_variable=(
    ["e"]="dir_excludes"
    ["f"]="file_excludes"
    ["i"]="file_includes"
    ["p"]="pattern_excludes"
    ["s"]="settings_modes"
)

# Define a list of variables to save in the configuration file
# This is also the order in which they will appear in the config file
# and the order in which they will appear in the md file output.
declare -g -a config_variables=(
    "create_date"
    "dir_excludes"
    "file_excludes"
    "pattern_excludes"
    "file_includes"
    "GENMD_BASE"
    "output_filename"
    "settings_modes"
    "dry_run"
    "debug_level"
    "use_gitignore"
    "follow_links"
    "remove_blanks"
    "add_line_numbers"
    "compress"
    "compression_tool"
    "count_tokens"
)

# Define a list of actions for each config variable based on whether to
# merge or set from the config file or the command line.
# the precedent will be from teh command line for some and from the
# config file for others, some may come from the environment variables
# and some may come from the config file or the command line.
declare -g -A config_variable_action=(
    ["GENMD_BASE"]="config"       # Set config file will override the environment variable
    ["add_line_numbers"]="set"    # Command line overrides all settings and preserved
    ["compress"]="set"            # Command line overrides all settings and preserved
    ["compression_tool"]="set"    # Command line overrides all settings and preserved
    ["count_tokens"]="set"        # Command line overrides all settings and preserved
    ["create_date"]="set"         # Command line overrides all settings and preserved
    ["debug_level"]="set"         # Command line overrides all settings and preserved
    ["dir_excludes"]="merge"      # Merge all sources.
    ["dry_run"]="discard"         # Command not preserved, but set from command line
    ["file_excludes"]="merge"     # Merge all sources.
    ["file_includes"]="merge"     # Merge all sources.
    ["follow_links"]="set"        # Command line overrides all settings and preserved
    ["output_filename"]="set"     # Command line overrides all settings
    ["pattern_excludes"]="merge"  # Merge all sources.
    ["remove_blanks"]="set"       # Command line overrides all settings and preserved
    ["settings_modes"]="set"      # Command line overrides all settings
    ["use_gitignore"]="set"       # Command line overrides all settings and preserved
)

# Set default values for command line options.
# Define file defaults.
declare -g add_line_numbers=false
declare -g compress=false
declare -g compression_tool="gzip"
declare -g config_dir="$GENMD_BASE/utils/etc"
declare -g count_tokens=false
#  shellcheck disable=SC2034,SC2155
declare -g create_date=$(date '+%Y-%m-%d %H:%M:%S')
declare -g debug_level=20
declare -g default_filename="combined_source"        # Default output filename
declare -g dry_run=false
declare -g follow_links=""
declare -g output_dir="$GENMD_BASE/utils/output"
declare -g remove_blanks=false
declare -g settings_modes=( "md" "cfg" )
declare -g skip_config=false                        # Set to true to skip loading config file
declare -g specified_config=""
declare -g specified_output=""
declare -g use_gitignore=true  

# Function to handle pattern-based array options from command line.
# Set the values of an array variable from a command line option.
#
#   Args:
#       $1: The name of the option (e.g. "file_excludes")
#       $2: The value of the option from the command line. This can be a string or a
#           pattern with the | character.
#       $3: The name of the target variable to be set.
#
# Returns:
#   None
#
set_option_value() {
    local opt_name="$1"
    local opt_value="$2"
    local target_variable=$3

    log_message "DEBUG3" "*** Setting command line options for $opt_name to \"$opt_value\""
    if [[ -n "$opt_value" && ! "$opt_value" =~ ^- ]]; then
        log_message "DEBUG1" "Load ${target_variable} with ${opt_name} values: ${opt_value}"
        handle_variable "${target_variable}" "$opt_value"
        # IFS='| ' readarray -t "${target_variable}" <  <( printf "%s" "$opt_value" )
    else
        display_help "ERROR ($MY_NAME): -$opt_name requires a pattern string." 
    fi
}

# Function to ensure a directory exists. If it does not, it creates it.
#
# Args:
#   $1 (string): The path of the directory to be checked.
#
# Returns:
#   None
#
check_directory() {
    local dir_path="$1"
    if [[ ! -d "$dir_path" ]]; then
        mkdir -p "$dir_path" || { log_message "ERROR" "Failed to create directory \"$dir_path\"."; exit 1; }
        log_message "WARNING" "Created directory \"$dir_path\"."
    fi
}

# sanitize_patterns - Sanitizes a string by retaining only alphanumerics, underscores, dots, dashes,
# and spaces.
#
# Usage:
#   sanitized_string=$(sanitize_patterns "$input")
#
# Examples:
#   $ sanitize_patterns "regex[0-9]._* "
#   regex[0-9].*
#
# Returns:
#   The sanitized string.
#
sanitize_patterns() {
    local input="$*"
    # Retain only alphanumerics, underscores, dots, dashes, and spaces
    cleanstring=${input//[^a-zA-Z0-9-_.* ]/}
    # cleanstring=$(echo "$input" | sed 's/[^a-zA-Z0-9_.* ]//g')
    log_message "DEBUG" "Dirty pattern: $input"
    log_message "DEBUG" "Clean pattern: $cleanstring"
    echo "$cleanstring"
}

# remove_duplicates - Remove duplicate elements from an array.
#
# Description:
#   Takes a named array reference as its only argument and removes any duplicate
#   elements from it. The function will preserve the original order of elements
#   but will remove any duplicates.
#
# Parameters:
#   $1: The named array reference to process.
#
# Returns:
#   The processed array with duplicates removed.
#
remove_duplicates() {
    local -n array_ref=$1
    declare -A seen
    local unique=()
    log_message "DEBUG1" "Removing duplicates from array '$1': '${array_ref[*]}'"
    
    # Double quote array expansions to avoid re-splitting elements.
    # shellcheck disable=SC2068
    for regex in ${array_ref[@]}; do
        # Skip empty patterns
        [[ -n "$regex" ]] || continue
        log_message "DEBUG2" "remove_duplicates input regex: $regex"
        if [[ -z "${seen[$regex]+_}" ]]; then
            seen["$regex"]=1
            unique+=("$regex")
        fi
    done

    log_message "DEBUG1" "Finished removing duplicates from array '$1' with total of ${#unique[@]}: '${unique[*]}'"
    array_ref=("${unique[@]}")
}

# parse_gitignore - Parse a .gitignore file for patterns to exclude/include
#
# Description:
#   Reads a .gitignore file and parses its contents to populate the
#   `gitignore_exclude` and `gitignore_includes` arrays. The function will
#   skip empty lines, comment lines, and regular exclusion patterns. If the
#   file does not exist, the function will log a message and exit.
#
# Parameters:
#   None
#
# Returns:
#   None
#
# Scope:
#   Global. Modifies the global arrays `gitignore_exclude` and `gitignore_includes`.
#
# Input:
#   Reads .gitignore file
#
# Output:
#   None
#
parse_gitignore() {
    local gitignore_file="$GENMD_BASE/.gitignore"
    
    if [[ -f "$gitignore_file" ]]; then
        log_message "INFO" "Parsing .gitignore file: $gitignore_file"
        
        while IFS= read -r line || [[ -n "$line" ]]; do
            # Trim leading and trailing whitespace
            line="$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
            [[ -z "$line" || "$line" =~ ^# ]] && continue
            
            if [[ "$line" =~ ^! ]]; then
                # Remove the '!' and add to gitignore_includes
                pattern="${line:1}"
                gitignore_includes+=("$pattern")
                log_message "DEBUG1" "Parsed .gitignore include pattern: $pattern"
                continue
            fi

            # Regular exclusion pattern
            gitignore_exclude+=("$line")
            log_message "DEBUG1" "Parsed .gitignore exclude pattern: $line"

        done < "$gitignore_file"
    else
        log_message "INFO" "No .gitignore file found at $gitignore_file. Skipping .gitignore integration."
    fi
}


# set_variable - Function to assign values to variables based on their names and type.
#
# Description:
#   Assigns a variable with the given name and value.
#
#   If the variable is an array, associative, or scalar, it is assigned
#   accordingly. Otherwise, it is treated as a scalar.
#
# Parameters:
#   $1: The name of the variable to assign.
#   $2: The value to assign.
#
set_variable() {
    local var_name="$1"
    shift
    local var_value="$*"

    # Declare and assign separately to avoid masking return values. SC2155
    # shellcheck disable=SC2155
    local var_type=$(var_type "$var_name")

    log_message "DEBUG2" "assign_variable: var_name=$var_name, var_value=\"$var_value\", var_type=$var_type"

    case "$var_type" in
        "array")
            IFS=' ' readarray -t "$var_name" <  <( printf "%s" "$var_value" )
            ;;
        "associative")
            IFS=' ' mapfile -g -t "$var_name" <  <( printf "%s" "$var_value" )
            ;;
        "scalar")
            declare -g "$var_name"="$var_value"
            ;;
        "integer")
            declare -g "$var_name=$var_value"
            ;;
         *)
            declare -g "$var_name"="$var_value"
            ;;
    esac
}

# handle_variable - Manage the assignment of variable values based on configuration actions.
#
# Description:
#   This function handles the assignment of variable values based on the specified
#   action defined in the `config_variable_action` associative array. It can merge,
#   set, configure, or discard values for a given variable.
#
# Parameters:
#   $1: The name of the variable to manage.
#   $2: The value to assign to the variable (if applicable).
#
# Actions:
#   - "merge": Merges the current value with the new value.
#   - "set": Sets the variable to the current value or a default.
#   - "config": Sets the variable from the config file.
#   - "discard": Preserves the current value without changes.
#
# Returns:
#   None
#
# Exit Codes:
#   2: Unknown action specified for variable.
#
handle_variable() {
    local var_name="$1"
    shift
    local var_value="$*"

    local current_value="${!var_name:-""}"

    case "${config_variable_action["$var_name"]}" in
        "merge")
            # Merge the current value with the value from the config file
            local -a mergevalue
            mergevalue=${current_value:-""}
            set_variable "$var_name" "${mergevalue[*]}" "${var_value}"
            ;;
        "set")
            # Set the variable from the command line or defaults
            set_variable "$var_name" "${current_value:-""}"
            ;;
        "config")
            # Set the variable from the config file setting
            set_variable "$var_name" "${!var_name:-""}"
            ;;
        "discard")
            # Preserve the current value
            set_variable "$var_name" "${current_value:-""}"
            ;;
        *)
            log_message "ERROR" "Unknown config_variable_action for variable \"$var_name\": ${config_variable_action["$var_name"]}"
            exit 2  # (ENOENT: 2): No such file or directory
            ;;
    esac
}


# load_config - Function to load configuration from a .grc file
#
# Description:
#   Loads a configuration file and assigns the variables using the config_variable_action array.
#
#   The config_variable_action array is used to determine how to assign the values from the config file:
#   - merge: the value will be added to the variable
#   - set: set the variable from the command line or defaults
#   - config: set the variable from the config file
#   - discard: the value not be preserved in the config file
#
# Parameters:
#   $1: The path to the configuration file to load.
#
load_config() {
    local config_file="$1"

    if [ "$skip_config" = true ]; then
        log_message "INFO" "Skipping config file loading."
        return 0
    fi

    if [[ -e "$config_file" ]]; then

        declare -A original_values
        declare -A config_values
        # Preserve the current values in temporary storage
        for var_name in "${config_variables[@]}"; do
            original_values["$var_name"]="${!var_name:-""}"
        done
        # shellcheck source=/dev/null
        source "$config_file"
        # Quickly put debug level back to default or from the command line it should not change
        # to value from config file.
        debug_level=${original_values["debug_level"]}
        # Set the new config file values and restore the original values
        for var_name in "${config_variables[@]}"; do
            config_values["$var_name"]="${!var_name:-""}"
            declare -g "$var_name"="${original_values["$var_name"]:-""}"
        done

        log_message "INFO" "Configuration loaded from \"$config_file\""
        # Iterate over config_variables and handle values accordingly
        for var_name in "${config_variables[@]}"; do
            # Determine whether variable is merged, set or discarded from the config file.
            handle_variable "$var_name" "${config_values["$var_name"]:-""}"  
            log_message "DEBUG2" "Final assignment variable: \"$var_name\" updated value: \"${!var_name:-""}\""
        done
    fi
}

# load_config_file - Function to determine and load configuration based on output and config file specifications
#
# Description:
#   This function determines which configuration file to load based on the output and config file specifications:
#   - If the output file is specified and the config file is specified, the specified config file is loaded.
#   - If the output file is specified but the config file is not specified, a new config file is created with the name of the output file.
#   - If the output file is not specified but the config file is specified, the specified config file is loaded.
#   - If neither the output file nor the config file is specified, the default config file is loaded.
#
# Parameters:
#   None.
#
load_config_file() {
    if [[ -n "$specified_output" && -n "$specified_config" ]]; then
        # Scenario: Output file specified and config file specified
        config_filename_in="${config_dir}/${specified_config}.grc"
        config_filename_out="$config_filename_in"
        output_filename="${output_dir}/${specified_config}.md"

        if [[ -e "$config_filename_in" ]]; then
            load_config "$config_filename_in"
        else
            log_message "ERROR" "Specified configuration file \"$config_filename_in\" does not exist."
            exit 2
        fi
    elif [[ -n "$specified_output" && -z "$specified_config" ]]; then
        # Scenario: Output file specified, config file not specified
        config_filename_in="${config_dir}/${specified_output}.grc"
        config_filename_out="${config_dir}/${specified_output}.grc"
        output_filename="${output_dir}/${specified_output}.md"

        if [[ -e "$config_filename_in" ]]; then
            load_config "$config_filename_in"
        else
            log_message "INFO" "No configuration file found for output \"$specified_output\", a new one will be created."
        fi
    elif [[ -z "$specified_output" && -n "$specified_config" ]]; then
        # Scenario: Output file not specified, config file specified
        config_filename_in="${config_dir}/${specified_config}.grc"
        config_filename_out="$config_filename_in"
        output_filename="${output_dir}/${specified_config}.md"

        if [[ -e "$config_filename_in" ]]; then
            load_config "$config_filename_in"
        else
            log_message "ERROR" "Specified configuration file \"$config_filename_in\" does not exist."
            exit 2
        fi
    else
        # Scenario: Neither output file nor config file specified
        config_filename_in="${config_dir}/${default_filename}.grc"
        config_filename_out="$config_filename_in"
        output_filename="${output_dir}/${default_filename}.md"

        if [[ -e "$config_filename_in" ]]; then
            load_config "$config_filename_in"
        else
            log_message "WARN" "No configuration or output file specified. Using default \"$output_filename\" and config \"$config_filename_out\""
        fi
    fi
}

# Function to display a short help message
# 
# ## Description
# - **Purpose**: 
#   - Displays a help message extracted from the script file.
# - **Usage**: 
#   - `display_help <message>`
# - **Input Parameters**: 
#   - `message`: A brief introduction or message to be included in the help text.
# - **Output**: 
#   - Displays the help text in a paginated format using the specified pager or defaults to `cat`.
# - **Exceptions**: 
#   - Calls `errno_exit` with an error code of 22 if an invalid argument is encountered.
# 
display_help() {
    # Initialize a variable to hold the help text
    local message=$1
    local help_text=""
    
    # Read the script file line by line
    help_text+="$message"$'\n\n'
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip the shebang line
        if [[ "$line" =~ ^#!/ ]]; then
            continue
        fi
        if [[ "$line" =~ ^$ ]]; then
            break
        fi
        if [[ "$line" =~ ^\#$ ]]; then
            help_text+=$'\n'
            continue
        fi
        if [[ "$line" =~ ^\#[[:space:]]* ]]; then
            help_text+="${line//\# /}"$'\n'
            continue
        fi
    done < "$0"

    printf "%s" "$help_text" | ${PAGER:-cat}
    errno_exit 22     # (EINVAL: 22): Invalid argument
}


# Function to build a single regex pattern from an array of patterns
#
# ## Description
# - **Purpose**: 
#   - Constructs a regex pattern by combining multiple input patterns from an array.
# - **Usage**: 
#   - `regex=$(build_regex "Caller message" patterns_array)`
# - **Input Parameters**: 
#   - `caller_message`: A message indicating the context of the caller function.
#   - `patterns_ref`: A reference to an array of patterns to be combined into a regex.
# - **Output**: 
#   - Returns a single regex pattern constructed from the input patterns.
# - **Exceptions**: 
#   - None.
#
build_regex() {
    local caller_message="$1"
    local -n patterns_ref=$2  # Reference to the array
    local regex=""
    local escaped_pattern

    log_message "DEBUG2" "$caller_message patterns: \"${patterns_ref[*]}\""

    for pattern in "${patterns_ref[@]}"; do
        log_message "DEBUG3" "$caller_message input pattern: \"$pattern\""
        # Escape special regex characters except for '*' and '|'
        escaped_pattern=$(echo "$pattern" | sed -E 's/([+.^(){}])/\\\1/g')        # Replace '*' with '.*' for wildcard matching
        escaped_pattern=${escaped_pattern//\*/.*}
        escaped_pattern=${escaped_pattern//^ $/}
        escaped_pattern=${escaped_pattern// /|}
        log_message "DEBUG3" "$caller_message escaped pattern: \"$escaped_pattern\""
        if [[ -z "$regex" ]]; then
            regex="$escaped_pattern"
        else
            regex="$regex|$escaped_pattern"
        fi
    done

    log_message "DEBUG2" "$caller_message final regex: \"$regex\""
    echo "$regex"
}

# Function to build a list of files to include in the combined source.
#
# Args:
#   $1 (array): A reference to the final files array.
#   $2 (array): A reference to the directory excludes array.
#   $3 (array): A reference to the pattern excludes array.
#   $4 (array): A reference to the gitignore exclude array.
#   $5 (array): A reference to the gitignore include array.
#   $6 (array): A reference to the file excludes array.
#   $7 (array): A reference to the file includes array.
#
# Returns:
#   None
#
build_file_list() {
    local -n final_files_ref=$1
    local -n dir_excludes_ref=$2
    local -n pattern_excludes_ref=$3
    local -n gitignore_exclude_ref=$4
    local -n gitignore_include_ref=$5
    local -n file_excludes_ref=$6
    local -n file_includes_ref=$7

    # Change to GENMD_BASE and perform find
    cd "$GENMD_BASE"
    readarray -t files < <(find ${follow_links:-} . -type f | sort )

    # Exclude directories in the exclude directory list
    if [[ ${#dir_excludes_ref[@]} -gt 0 ]]; then
        local dir_excludes_regex
        dir_excludes_regex=$(build_regex "Exclude directories" "dir_excludes_ref" | sed -E 's/([^|]+)/\/\1\//g')
        # Remove files within excluded directories
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -vE "($dir_excludes_regex)")
    fi

    # Exclude files based on file patterns
    if [[ ${#file_excludes_ref[@]} -gt 0 ]]; then
        local file_excludes_regex
        file_excludes_regex=$(build_regex "Exclude files" "file_excludes_ref")
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -vE "$file_excludes_regex")
    fi

    # Exclude files based on .gitignore exclude patterns
    if [[ ${#gitignore_exclude_ref[@]} -gt 0 ]]; then
        local git_exclude_regex
        git_exclude_regex=$(build_regex "Gitignore exclude" "gitignore_exclude_ref")
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -vE "$git_exclude_regex")
    fi

    # Exclude any strings in the extra pattern list
    if [[ ${#pattern_excludes_ref[@]} -gt 0 ]]; then
        local pattern_excludes_regex
        pattern_excludes_regex=$(build_regex "Exclude patterns" "pattern_excludes_ref")
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -vE "$pattern_excludes_regex")
    fi

    # Re-include files based on .gitignore include patterns
    if [[ "${use_gitignore}" = true && ${#gitignore_include_ref[@]} -gt 0 ]]; then
        local git_include_regex
        git_include_regex=$(build_regex "Gitignore include" "gitignore_include_ref")
        # Find files that match include patterns and add them back
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -E "$git_include_regex")
    fi

    # Include only files explicitly specified in the include file list
    if [[ ${#file_includes_ref[@]} -gt 0 ]]; then
        local file_includes_regex
        file_includes_regex=$(build_regex "Include files" "file_includes_ref")
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -E "$file_includes_regex")
    fi

    # Passing back the array reference
    # shellcheck disable=SC2034
    final_files_ref=("${files[@]}")
}

# Function to generate markdown for a source file.
#
# Args:
#   $1 (string): The source file to generate markdown for.
#   $2 (string): The type of markdown to generate.
#
# Returns:
#   None
#
generate_markdown() {
    local source_file="$1"
    local markdown_type="$2"

    if [[ "$dry_run" = true ]]; then
        log_message "INFO" "Dry run: Would generate markdown type '$markdown_type' for: $source_file"
        return
    fi

    log_message "INFO" "Generating markdown for: $source_file"

    # Create a temporary file for processing
    local temp_file
    temp_file=$(mktemp)

    # Optionally remove blank lines and strip trailing spaces
    if [[ "$remove_blanks" = true ]]; then
        # Remove blank lines and lines with only spaces, then strip trailing spaces
        sed '/^\s*$/d;s/[[:space:]]\+$//' "$source_file" > "$temp_file"
    else
        cp "$source_file" "$temp_file"
    fi

    # Optionally add line numbers
    if [[ "$add_line_numbers" = true ]]; then
        nl -n'rn' -b'a' "$temp_file" > "${temp_file}.numbered"
        mv "${temp_file}.numbered" "$temp_file"
    fi

    {
        printf "\n\n## Filename ==>  %s\n\`\`\`%s\n" "$source_file" "$markdown_type"
        # Escape backticks for markdown
        cat < "$temp_file" | sed "s/\`\`\`/\\\\\`\\\\\`\\\\\`/g"
        printf "\n\`\`\`\n"
    } >> "$output_filename"

    # Remove the temporary file
    rm "$temp_file"
}

# Function to generate the filetree markdown.
#
# Args:
#   $1 (string): The output filename.
#   $2 (array): The list of excluded directories.
#
# Returns:
#   None
#
generate_filetree() {
    local output_filename=$1
    local -n include_list_ref=$2
    shift; shift
    local exclude_list="$*"

    #local include_list="${include_list_ref[*]}"

    include_string=$(sanitize_patterns "${include_list_ref[@]}")
    exclude_string=$(sanitize_patterns "${exclude_list[@]}")

    if ! command -v filetree >/dev/null 2>&1; then
        log_message "ERROR" "'filetree' command not found. Please install it or use an alternative."
        log_message "ERROR" "It should have been included with this script and it should be in your \$PATH."
        exit 2  # (ENOENT: 2): No such file or directory
    fi

    if [[ "$dry_run" = true ]]; then
        log_message "INFO" "Dry run: Generating directory and file structure."
        # shellcheck disable=SC2086
        filetree -l $debug_level  -i "${include_string}" -e tmp .git "${exclude_string[@]}"
        return
    fi

    log_message "INFO" "Generating directory and file structure, including: ${include_string}, excluding: ${exclude_string}"

    {
        printf "\n\n## Project filesystem directory structure\n\`\`\`text\n"
        # Double quote to prevent globbing and word splitting.shellcheckSC2086
        # shellcheck disable=SC2086
        echo filetree -l $debug_level -i "${include_string}" -e tmp .git "${exclude_string}"
        # shellcheck disable=SC2086
        filetree -l $debug_level -i "${include_string}" -e tmp .git "${exclude_string}"
        printf "\n\`\`\`\n"
    } >> "$output_filename"
}

# Function to get the file type using the `file` command.
#
# Args:
#   $1 (string): The output filename.
#   $2 (array): A reference to the final files array.
#
# Returns:
#   None
#
process_files() {
    local output_filename="$1"
    local -n files_ref="$2"
    # Iterate over files and generate markdown
    for file in "${files_ref[@]}"; do
        # Determine file type based on extension
        local file_type
        local file_description
        file_description=$(file -b "$file")
        case "$file_description" in
            *Bourne-Again*) file_type="bash";;
            *Bourne*) file_type="sh";;
            *HTML*) file_type="html";;
            *html\ *) file_type="html";;
            *JSON*) file_type="json";;
            *JavaScript*) file_type="javascript";;
            *Java*) file_type="java";;
            *Markdown*) file_type="markdown";;
            *PHP*) file_type="php";;
            *[Pp]erl*) file_type="perl";;
            *Python*) file_type="python";;
            *[Rr]uby*) file_type="ruby";;
            *SASS*) file_type="sass";;
            *SCSS*) file_type="scss";;
            *CSS*) file_type="css";;
            *shell*) file_type="sh";;
            *Shell*) file_type="bash";;
            *[Tt]ext*)
                # if teh description from the file command returns a match on .txt or .text,
                # check the suffix of the file and if it's valid, like js, scss, md, html,
                # set filetype to the extension of the file
                local file_suffix="${file##*.}"
                case "$file_suffix" in
                    js) file_type="javascript";;
                    scss) file_type="scss";;
                    md) file_type="markdown";;
                    html) file_type="html";;
                    *) file_type="text";;
                esac
            ;;
            *YAML*) file_type="yaml";;
            *) file_type="unknown";;
        esac
        if [[ "$file_type" = "unknown" ]]; then
            log_message "INFO" "Skipping unknown $file_description type: \"$file\""
            continue
        fi
        log_message DEBUG2 "File description: $file_description Converts to: $file_type" 
        generate_markdown "$file" "$file_type"
    done
}

# compress_output-  Function to compress the final output
#
# Compress the final output using the specified compression tool if it exists.
#
# Args:
#     $1 (string): The filename of the output to compress.
#
# Returns:
#     0: Success
#     1: Failure to compress
#
compress_output() {
    local output_filename="$1"

    if [[ "$compress" = true ]]; then
        if ! command -v "$compression_tool" &>/dev/null; then
            log_message "WARNING" "Compression tool $compression_tool not found skipping compression"
            return 1
        fi
        case "$compression_tool" in
            gzip) extension="gz";;
            bzip2) extension="bz2";;
            xz) extension="xz";;
            *) log_message "WARNING" "Compression tool $compression_tool not supported skipping compression"
                return 1;;
        esac

        $compression_tool - < "$output_filename" > "${output_filename}.${extension}"
        log_message "INFO" "Final compressed output is ${output_filename}.${extension}"
    fi
}


# Function to save configuration to a .grc file
#
# This function saves the configuration variables defined in the script to a specified .grc file.
# It checks the output directory and writes each variable to the file in a format suitable for 
# environment variable export. Special handling is applied for specific variables to ensure they 
# are exported correctly.
#
# Args:
#     None
#
# Returns:
#     None
#
# Logs:
#     INFO messages indicating the saving process and the final output file location.
save_config() {
    #echo "CALLING save_config"
    local config_file="${config_filename_out}"
    check_directory "$(dirname "$config_file")"

    {
        log_message "INFO" "Saving configuration to $config_file"
        # shellcheck disable=SC2068
        for var in ${config_variables[@]}; do
            log_message "INFO" "Saving $var type: $(var_type "$var") value: \"${!var:-""}\""
            case "$var" in
                GENMD_DIR_EXCLUDES|GENMD_FILE_EXCLUDES|GENMD_PATTERN_EXCLUDES|GENMD_FILE_INCLUDES)
                    echo "export $var=\"${!var:-""}\""
                    ;;
                *)
                    echo "$var=\"${!var:-""}\""
                    ;;
            esac
        done
    } > "$config_file"

    log_message "INFO" "Configuration saved to $config_file"
}

# Function to display or write out the current settings
#
# This function takes an array of modes and performs actions based on the provided modes.
# It can display settings information, generate markdown documentation of the settings,
# save the configuration to a file, or export environment variables to a script.
#
# Args:
#     $1 (array): An array of modes indicating what settings to display or write out.
#                  Possible modes are:
#                  - "all": Sets modes to ["info", "md", "cfg", "env"]
#                  - "info": Displays the current settings in the log.
#                  - "md": Generates markdown documentation of the settings.
#                  - "cfg": Saves the current configuration to a .grc file.
#                  - "env": Exports the current settings as environment variable declarations in a script.
#
# Returns:
#     None
#
# Logs:
#     INFO messages indicating the current settings and actions taken.
#     WARN messages for any unknown modes passed to the function.
display_settings() {
    local -n modes=$1  # Array of modes passed to the function

    if [[ " ${modes[*]} " =~ " all " ]]; then
        modes=("info" "md" "cfg" "env")
    fi

    for mode in "${modes[@]}"; do
        case "$mode" in
            info)
                log_message "INFO" "genmd current settings:"
                # shellcheck disable=SC2068
                for var in ${config_variables[@]}; do
                    log_message "INFO" "$var: ${!var:-""}"
                done
                ;;
            md)
                {
                    echo "## genmd Settings"
                    echo ""
                    echo "| Variable               | Value                                                                 |"
                    echo "|------------------------|-----------------------------------------------------------------------|"
                    # shellcheck disable=SC2068
                    for var in ${config_variables[@]}; do
                        local value=${!var:-""}
                        # Escape or pattern match characters
                        value=${value//|/\\|}
                        # shellcheck disable=SC2086
                        printf "| %s | %s |\n" "$var" ${value}
                    done
                    echo ""
                } >> "$output_filename"
                ;;
            cfg)
                save_config
                ;;
            env)
                {
                    echo ""
                    echo "## genmd Environment Variables"
                    echo ""
                    for var in "${config_variables[@]}"; do
                        printf "export %s=\"%s\"\n" "$var" "${!var:-""}"
                    done
                    echo ""
                } > "${GENMD_BASE}/genmd_env.sh"
                ;;
            *)
                log_message "WARN" "Unknown mode '$mode' for --settings"
                ;;
        esac
    done
}


# Processing begins here with command line options

# Process command-line options using getopts
# Reset OPTIND in case getopts has been used previously
OPTIND=1
while getopts ":d:he:f:i:p:o:c:s:nvgCbLltz:-:" opt; do
    case "$opt" in
        # Short options
        d)
            if [[ "$OPTARG" -ge 1 && "$OPTARG" -le 99 ]]; then
                debug_level="$OPTARG"
                if [[ "$debug_level" -eq 1 ]]; then
                    set -x
                fi
            else
                display_help "ERROR ($MY_NAME): Debug level must be between 10 and 99."
            fi
            ;;
        e|f|i|p|s)
            set_option_value "$opt" "$OPTARG" "${option_variable[$opt]}"
            ;;
        o)
            value="${OPTARG#*=}"
            specified_output="$(basename "$value" .md)"
            ;;
        c)
            value="${OPTARG#*=}"
            specified_config="$(basename "$value" .grc)"
            ;;
        n)
            dry_run=true
            ;;
        g)
            use_gitignore=false  # Disable gitignore integration
            ;;
        L)
            follow_links="-L"    # Follow symlinks
            ;;
        C)
            skip_config=true     # New option to skip config files
            ;;
        b)
            remove_blanks=true
            ;;
        l)
            add_line_numbers=true
            ;;
        t)
            count_tokens=true
            ;;
        z)
            compress=true
            compression_tool="$OPTARG"
            # Validate compression tool
            case "$compression_tool" in
                gzip|xz|bzip2)
                    ;;
                *)
                    log_message "WARNING" "Unsupported compression tool '$compression_tool', using gzip for compression."
                    ;;
            esac
            ;;
        h)
            display_help ""
            ;;
        -)
            # Handle long options manually
            case "${OPTARG}" in
                debug=*)
                    if [[ "$OPTARG" -ge 1 && "0$OPTARG" -le 99 ]]; then
                        debug_level="$OPTARG"
                        if [[ "$debug_level" -eq 1 ]]; then
                            set -x
                        fi
                    else
                        display_help "ERROR ($MY_NAME): Debug level must be between 0 and 99."
                    fi
                    ;;
                help)
                    display_help ""
                    ;;
                exclude=*)
                    set_option_value "exclude" "${OPTARG#*=}" dir_excludes
                    ;;
                file=*)
                    set_option_value "file" "${OPTARG#*=}" file_excludes
                    ;;
                include=*)
                    set_option_value "include" "${OPTARG#*=}" file_includes
                    ;;
                pattern=*)
                    set_option_value "pattern" "${OPTARG#*=}" pattern_excludes
                    ;;
                output=*)
                    value="${OPTARG#*=}"
                    specified_output="$(basename "$value" .md)"
                    ;;
                config=*)
                    value="${OPTARG#*=}"
                    specified_config="$(basename "$value" .grc)"
                    ;;
                settings=*)
                    set_option_value "pattern" "${OPTARG#*=}" settings_modes
                    ;;
                no-gitignore)
                    use_gitignore=false
                    ;;
                follow-links)
                    follow_links="-L"
                    ;;
                no-config)
                    skip_config=true
                    ;;
                remove-blanks)
                    remove_blanks=true
                    ;;
                line-numbers)
                    add_line_numbers=true
                    ;;
                tokens)
                    count_tokens=true
                    ;;
                compress=*)
                    compress=true
                    compression_tool="${OPTARG#*=}"
                    # Validate compression tool
                    case "$compression_tool" in
                        gzip|xz|bzip2)
                            ;;
                        *)
                            display_help "ERROR ($MY_NAME): Unsupported compression tool '$compression_tool'. Supported tools are gzip, xz, bzip2."
                            ;;
                    esac
                    ;;
                *)
                    display_help "ERROR ($MY_NAME): Unknown option '--${OPTARG}'"
                    ;;
            esac
            ;;
        \?)
            display_help "ERROR ($MY_NAME): Invalid option '-$OPTARG'"
            ;;
        :)
            display_help "ERROR ($MY_NAME): Option '-$OPTARG' requires an argument."
            ;;
        ?)
            display_help "ERROR ($MY_NAME): Unknown option '-$OPTARG'"
            ;;
    esac
done

# Shift off the options and optional --
shift $((OPTIND -1))

# Ensure necessary directories exist
check_directory "$output_dir"
check_directory "$config_dir"

# Determine and load configuration based on output and config file specifications
load_config_file

# Parse .gitignore and populate gitignore_exclude and gitignore_include if enabled
if [[ "$use_gitignore" = true ]]; then
    parse_gitignore
fi

# Remove duplicates from exclusion and inclusion lists
remove_duplicates dir_excludes
remove_duplicates file_excludes
remove_duplicates pattern_excludes
remove_duplicates gitignore_exclude
remove_duplicates gitignore_include
remove_duplicates file_includes

remove_duplicates settings_modes

# Truncate the output file only if not in dry_run
if [[ "$dry_run" != true ]]; then
    : > "$output_filename"
else
    log_message "INFO" "Dry run: Skipping truncation of $output_filename"
fi

# After truncating, handle the settings_modes to include info at the top
if [[ ${#settings_modes[@]} -gt 0 ]]; then
    display_settings settings_modes
fi

# Debug: Show final directory exclusions
log_message "DEBUG1" "Final directory exclusions: ${dir_excludes[*]}"


# Generate file tree markdown
# Argument mixes string and array. Use * or separate argument.
# shellcheck disable=SC2145
generate_filetree "$output_filename" file_includes "${dir_excludes[@]}" "${pattern_excludes[@]}" "${file_excludes[@]}"

# Build the file list
build_file_list final_files dir_excludes \
                pattern_excludes gitignore_exclude \
                gitignore_include file_excludes \
                file_includes

# Debug: Show final files to be processed
{
    printf "## Files included in final output\n"
    # shellcheck disable=SC2154,SC2068
    for f in ${final_files[@]}; do
        printf -- "- %s\n" "$f"
    done
    printf "\n---\n"
} >> "$output_filename"

# Process the files and generate markdown
process_files "$output_filename" final_files

# Provide token count if requested
if [[ "$count_tokens" = true ]]; then
    tokencount -f "${output_filename}"
fi

# Compress the final output if compression is enabled
if [[ "$compress" = true ]]; then
    compress_output "${output_filename}"
fi

log_message "INFO" "       Output file: $output_filename"
log_message "INFO" "Configuration file: $config_filename_out"