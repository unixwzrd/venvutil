#!/usr/bin/env bash
#
# Name:
#       genmd - Combined source code markdown generator.
#
# Usage:
#       genmd [options]
#
# Options:
#       -d, --debug [level]   Set debug level (0-9)
#                             0: No debug output
#                             1: Show informational messages
#                             2: Show debug messages
#                             3: Show regex commands and patterns
#                             9: Show xtrace messages
#       -h, --help            Show this help message
#       -e, --exclude ["patterns" | excludefile]
#                             Exclude directories matching the given strings or from a file.
#                             Multiple patterns can be separated by '|'.
#       -f, --file ["patterns" | excludefile]
#                             Exclude files matching the given strings or from a file.
#                             Multiple patterns can be separated by '|' or spaces.
#       -i, --include ["patterns" | includefile]
#                             Include only files matching the given strings or from a file.
#                             Multiple patterns can be separated by '|'.
#       -p, --pattern ["patterns" | patternfile]
#                             Exclude additional patterns matching the given strings or from a file.
#                             Multiple patterns can be separated by '|' or spaces.
#       -o, --output [filename]
#                             Output file (default: combined_source.md)
#       -c, --config [save|load] [filename]
#                             Save or load the current configuration to/from a .grc file.
#                             If saving, defaults to output filename with .grc extension if filename not provided.
#       -s, --settings [modes] Show settings. Modes can be:
#                             info: Show current settings
#                             md: Include settings in markdown output
#                             env: Output settings as environment variables
#                             all: Perform info, md, and env actions
#       -n, --dry-run         Do not write the output file; print the files to be processed.
#       -v, --verbose         Show verbose output
#
# Description:
#       The genmd script generates markdown from the files in the specified directory,
#       excluding files and directories based on provided patterns. It outputs:
#       - Project filesystem directory structure
#       - Source code in a single markdown file for all included files.
#       - Excluded files are omitted based on exclusion patterns.
#
# Examples:
#       genmd -e '*.md$|*.html$|*.liquid$' -i 'ss' -o output.md
#       genmd --exclude exclude_patterns.txt --include include_patterns.txt --dry-run
#       genmd -c save my_config.grc -d 2
#
# Environment:
#       GENMD_BASE: The base directory to search for files in.
#       GENMD_FILE_EXCLUDES: A default list of file patterns to exclude from the generated markdown.
#       GENMD_FILE_INCLUDES: A default list of file patterns to include in the generated markdown.
#       GENMD_DIR_EXCLUDES: A default list of directory patterns to exclude from the generated markdown.
#       GENMD_PATTERN_EXCLUDES: A default list of additional patterns to exclude from the generated markdown.
#       PAGER: The pager to use for output, defaults to `less -R`
#
# Author:
#       Michael Sullivan <unixwzrd@unixwzrd.ai>
#           https://unixwzrd.ai/
#           https://github.com/unixwzrd
#
# License:
#       Apache License, Version 2.0
#

# Ensure the script exits on error and treats unset variables as errors
set -euo pipefail

# Check for Bash version 4+
if [ "${BASH_VERSINFO[0]}" -lt 4 ]; then
    echo "Error: genmd requires Bash version 4 or higher." >&2
    exit 75     # (EPROGMISMATCH: 75): Program version wrong
fi

# Define an array of variable names to display
settings_variables=(
    "GENMD_FILE_EXCLUDES"
    "GENMD_DIR_EXCLUDES"
    "GENMD_PATTERN_EXCLUDES"
    "GENMD_FILE_INCLUDES"
    "GENMD_BASE"
    "output_filename"
    "dry_run"
    "debug_level"
    "verbose"
)

my_name="$(basename "${BASH_SOURCE[0]}")"

# Improved handling of GENMD_BASE
# Allow the user to set GENMD_BASE externally, else default to the parent directory of the script
GENMD_BASE="${GENMD_BASE:-.${BASE_DIR}}"

# Source the default configuration file if it exists
if [ -e "$GENMD_BASE/utils/etc/genmd.rc" ]; then
    # shellcheck disable=SC1091
    source "$GENMD_BASE/utils/etc/genmd.rc"
fi

# Initialize include and exclude arrays with default exclusions or environment variables
read -r -a file_excludes <<< "${GENMD_FILE_EXCLUDES:-*.ico *.svg *.png *.pdf *.jpg *.htaccess *.webp *.jekyll .DS_Store combined_source.md *.JPG *.png}"
read -r -a dir_excludes <<< "${GENMD_DIR_EXCLUDES:-tmp}"
read -r -a pattern_excludes <<< "${GENMD_PATTERN_EXCLUDES:-}"
read -r -a file_includes <<< "${GENMD_FILE_INCLUDES:-footer|social|ss|liquid|\.md}"

# Flags
dry_run=false
debug_level=0
verbose=false
settings_modes=()

# Function to display help message
display_help() {
    cat <<_EOT_ | ${PAGER:-less -R}

Usage: $my_name [options]

Options:
  -d, --debug [level]   Set debug level (0-9)
                          0: No debug output
                          1: Show informational messages
                          2: Show debug messages
                          3: Show regex commands and patterns
                          9: Show xtrace messages
  -h, --help            Show this help message
  -e, --exclude ["patterns" | excludefile]
                          Exclude directories matching the given strings or from a file.
                          Multiple patterns can be separated by '|'.
  -f, --file ["patterns" | excludefile]
                          Exclude files matching the given strings or from a file.
                          Multiple patterns can be separated by '|' or spaces.
  -i, --include ["patterns" | includefile]
                          Include only files matching the given strings or from a file.
                          Multiple patterns can be separated by '|'.
  -p, --pattern ["patterns" | patternfile]
                          Exclude additional patterns matching the given strings or from a file.
                          Multiple patterns can be separated by '|' or spaces.
  -o, --output [filename]
                          Output file (default: combined_source.md)
  -c, --config [save|load] [filename]
                          Save or load the current configuration to/from a .grc file.
                          If saving and filename not provided, defaults to output filename with .grc extension.
  -s, --settings [modes] Show settings. Modes can be:
                          info: Show current settings
                          md: Include settings in markdown output
                          env: Output settings as environment variables
                          all: Perform info, md, and env actions
  -n, --dry-run         Do not write the output file; print the files to be processed.
  -v, --verbose         Show verbose output

Examples:
  $my_name -d 2 -f "professional.md *.png" -i "footer social ss liquid .md" -e "_includes"
  $my_name --exclude exclude_patterns.txt --include include_patterns.txt --dry-run
  $my_name -c save my_config.grc -d 2

Author: Michael Sullivan <unixwzrd@unixwzrd.ai>
        https://unixwzrd.ai/
        https://github.com/unixwzrd

License: Apache License, Version 2.0

_EOT_
    exit 22     # (EINVAL: 22): Invalid argument
}

# Function to display current settings
display_settings() {
    local modes=("$@")  # Array of modes passed to the function

    for mode in "${modes[@]}"; do
        case "$mode" in
            info)
                echo "genmd current settings" >&2
                for var in "${settings_variables[@]}"; do
                    # Use indirect reference to get the variable's value
                    local -n value="$var"
                    echo "$var:    $value" >&2
                done
                ;;
            md)
                {
                    echo "## genmd Settings"
                    echo ""
                    echo "| Variable               | Value                                                                 |"
                    echo "|------------------------|-----------------------------------------------------------------------|"
                    for var in "${settings_variables[@]}"; do
                        local value="${!var}"
                        # Escape pipe characters in value to prevent table breaking
                        value="${value//|/\\|}"
                        echo "| $var | $value |"
                    done
                } >> "$output_filename"
                ;;
            env)
                {
                    echo ""
                    echo "## genmd Environment Variables"
                    echo ""
                    for var in "${settings_variables[@]}"; do
                        local value="${!var}"
                        echo "export $var=\"$value\""
                    done
                } >> "$output_filename"
                ;;
            all)
                display_settings "info" "md" "env"
                ;;
            *)
                echo "Error: Unknown mode '$mode' for --settings" >&2
                exit 22
                ;;
        esac
    done
}

sanitize_patterns() {
    # Retain alphanumerics, underscores, dots, asterisks, pipes, and spaces
    cleanstring=$(printf "%s" "$1" | sed -E 's/[^a-zA-Z0-9._*| ]//g')
    if [[ "$debug_level" -gt 1 ]]; then
        echo "DEBUG ($my_name): Dirty pattern: $1" >&2
        echo "DEBUG ($my_name): Clean pattern: $cleanstring" >&2
    fi
    echo "$cleanstring"
}

# Function to build a single regex pattern from an array of patterns
build_regex() {
    local caller_message="$1"
    local -n patterns_ref=$2  # Reference to the array
    local regex=""
    local escaped_pattern

    if [[ "$debug_level" -gt 1 ]]; then
        echo "DEBUG ($my_name): $caller_message patterns: ${patterns_ref[@]}" >&2
    fi

    for pattern in "${patterns_ref[@]}"; do
        if [[ "$debug_level" -gt 2 ]]; then
            echo "DEBUG ($my_name): $caller_message input pattern: $pattern" >&2
        fi
        # Escape special regex characters except for '*' and '|'
        escaped_pattern=$(printf "%s" "$pattern" | sed -E 's/([.+^(){}])/\\\1/g')
        # Replace '*' with '.*' for wildcard matching
        escaped_pattern=${escaped_pattern//\*/.*}
        # '|' is already handled as pattern separators
        if [[ "$debug_level" -gt 2 ]]; then
            echo "DEBUG ($my_name): $caller_message escaped pattern: $escaped_pattern" >&2
        fi
        if [[ -z "$regex" ]]; then
            regex="$escaped_pattern"
        else
            regex="$regex|$escaped_pattern"
        fi
    done

    if [[ "$debug_level" -gt 1 ]]; then
        echo "DEBUG ($my_name): $caller_message final regex: $regex" >&2
    fi

    echo "$regex"
}

# Function to build a list of files to include in the combined source
build_file_list() {
    local -n files_ref=$1
    local -n include_files_ref=$2
    local -n exclude_files_ref=$3
    local -n exclude_dirs_ref=$4
    local -n pattern_excludes_ref=$5

    # Find all files
    readarray -t files < <(find "$GENMD_BASE" -type f | sort -u)

    # Exclude directories in the exclude directory list
    if [[ ${#exclude_dirs_ref[@]} -gt 0 ]]; then
        for dir in "${exclude_dirs_ref[@]}"; do
            # Remove files within excluded directories
            files=("${files[@]/*\/$dir\/*}")
        done
    fi

    # Exclude files based on file patterns
    if [[ ${#exclude_files_ref[@]} -gt 0 ]]; then
        local exclude_files_regex
        exclude_files_regex=$(build_regex "Exclude files" "exclude_files_ref")
        if [[ "$debug_level" -gt 2 ]]; then
            echo "DEBUG ($my_name): Excluding files with regex: $exclude_files_regex" >&2
        fi
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -vE "$exclude_files_regex")
    fi

    # Exclude any strings in the extra pattern list
    if [[ ${#pattern_excludes_ref[@]} -gt 0 ]]; then
        local pattern_excludes_regex
        pattern_excludes_regex=$(build_regex "Exclude patterns" "pattern_excludes_ref")
        if [[ "$debug_level" -gt 2 ]]; then
            echo "DEBUG ($my_name): Excluding patterns with regex: $pattern_excludes_regex" >&2
        fi
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -vE "$pattern_excludes_regex")
    fi

    # Include only files explicitly specified in the include file list
    if [[ ${#include_files_ref[@]} -gt 0 ]]; then
        local include_files_regex
        include_files_regex=$(build_regex "Include files" "include_files_ref")
        if [[ "$debug_level" -gt 2 ]]; then
            echo "DEBUG ($my_name): Including files with regex: $include_files_regex" >&2
        fi
        readarray -t files < <(printf "%s\n" "${files[@]}" | grep -E "$include_files_regex")
    fi

    # Passing back the array reference
    files_ref=("${files[@]}")
}

# Function to generate markdown for a source file
generate_markdown() {
    local source_file="$1"
    local markdown_type="$2"

    if [[ "${dry_run:-false}" = true ]]; then
        echo "Would generate markdown type '$markdown_type' for: $source_file" >&2
        return
    fi

    if [[ "${verbose:-false}" = true || "$debug_level" -gt 0 ]]; then
        echo "INFO ($my_name): Generating markdown for: $source_file" >&2
    fi

    {
        printf "\n\n## Filename ==>  %s\n\`\`\`%s\n" "$source_file" "$markdown_type"
        cat "$source_file"
        printf "\n\`\`\`\n"
    } >> "$output_filename"
}

# Function to generate the filetree markdown
generate_filetree() {
    local output_filename="$1"
    shift
    local exclude_list=("$@")
    if [ "$debug_level" -gt 0 ]; then
        echo "INFO ($my_name): Generating directory and file structure excluding: ${exclude_list[@]}" >&2
    fi

    if ! command -v filetree >/dev/null 2>&1; then
        printf "Error: 'filetree' command not found. Please install it or use an alternative.\n" >&2
        printf "It should have been included with this script and it should be in your \$PATH.\n" >&2
        exit 2 # (ENOENT: 2): No such file or directory
    fi

    if [[ "${dry_run:-false}" = true ]]; then
        echo "Generating directory and file structure." >&2
        filetree --exclude "${exclude_list[@]}"
        return
    fi

    {
        printf "\n\n## Project filesystem directory structure\n\`\`\`text\n"
        filetree --exclude "${exclude_list[@]}"
        printf "\n\`\`\`\n"
    } >> "$output_filename"
}

# Function to get the file type using the `file` command
get_unknown_filetype() {
    local file_path="$1"
    local file_description
    file_description=$(file -b "$file_path")
    case "$file_description" in
        *Bourne-Again*) echo "bash";;
        *Bourne*) echo "sh";;
        *HTML*) echo "html";;
        *JSON*) echo "json";;
        *JavaScript*) echo "javascript";;
        *Java*) echo "java";;
        *Markdown*) echo "markdown";;
        *PHP*) echo "php";;
        *[P|p]erl*) echo "perl";;
        *Python*) echo "python";;
        *[R|r]uby*) echo "ruby";;
        *SASS*) echo "sass";;
        *SCSS*) echo "scss";;
        *CSS*) echo "css";;
        *shell*) echo "sh";;
        *Shell*) echo "bash";;
        *[T|t]ext*) echo "text";;
        *YAML*) echo "yaml";;
        *) echo "unknown";;
    esac
}

# Function to process a list of files and generate markdown
process_files(){
    local output_filename=$1
    local -n files_ref=$2
    # Iterate over files and generate markdown
    for file in "${files_ref[@]}"; do
        # Determine file type based on extension
        local filetype
        case "$file" in
            *".css") filetype="css";;
            *".html") filetype="html";;
            *".js") filetype="javascript";;
            *".json") filetype="json";;
            *".md") filetype="markdown";;
            *".py") filetype="python";;
            *".rb") filetype="ruby";;
            *".sass") filetype="sass";;
            *".scss") filetype="scss";;
            *".sh") filetype="bash";;
            *".txt") filetype="text";;
            *".yml") filetype="yaml";;
            # Resolve any types which don't have a known extension using file magic
            *) filetype=$(get_unknown_filetype "$file");;
        esac
        if [[ "$filetype" = "unknown" ]]; then
            echo "ERROR ($my_name): Skipping unknown file type: $file" >&2
            continue
        fi
        generate_markdown "$file" "$filetype"
    done
}

# Function to remove duplicates from arrays
remove_duplicates() {
    local -n arr_ref=$1
    declare -A seen
    local unique=()
    for item in "${arr_ref[@]}"; do
        if [[ -z "${seen[$item]}" ]]; then
            seen[$item]=1
            unique+=("$item")
        fi
    done
    arr_ref=("${unique[@]}")
}

# Process command-line options using getopt for better long option support
TEMP=$(getopt -o d:he:f:i:p:o:cnvs: -l debug:,help,exclude:,file:,include:,pattern:,output:,config:,settings:,dry-run,verbose -- "$@")
if [ $? != 0 ]; then
    echo "Error: Failed to parse options." >&2
    exit 1
fi
eval set -- "$TEMP"

while true; do
    case "$1" in
        -c|--config)
            if [[ -n "$2" ]]; then
                action="$2"
                filename="$3"
                if [[ "$action" == "save" ]]; then
                    if [[ -n "$filename" && "$filename" != "save" && "$filename" != "load" ]]; then
                        config_file="$GENMD_BASE/utils/etc/$filename"
                    else
                        # If filename is not provided, derive from output_filename
                        basename=$(basename "$output_filename" .md)
                        config_file="$GENMD_BASE/utils/etc/${basename}.grc"
                    fi
                    {
                        echo "GENMD_DIR_EXCLUDES=\"$GENMD_DIR_EXCLUDES\""
                        echo "GENMD_FILE_EXCLUDES=\"$GENMD_FILE_EXCLUDES\""
                        echo "GENMD_FILE_INCLUDES=\"$GENMD_FILE_INCLUDES\""
                    } > "$config_file"
                    echo "INFO ($my_name): Configuration saved to $config_file" >&2
                    shift 2
                elif [[ "$action" == "load" ]]; then
                    if [[ -n "$filename" ]]; then
                        config_file="$GENMD_BASE/utils/etc/$filename"
                        if [[ -f "$config_file" ]]; then
                            source "$config_file"
                            echo "INFO ($my_name): Configuration loaded from $config_file" >&2
                        else
                            echo "Error: Configuration file $config_file not found." >&2
                            exit 1
                        fi
                        shift 2
                    else
                        echo "Error: --config load requires a filename." >&2
                        display_help
                    fi
                else
                    # Default to save if action is not specified
                    config_file="$GENMD_BASE/utils/etc/$2.grc"
                    {
                        echo "GENMD_DIR_EXCLUDES=\"$GENMD_DIR_EXCLUDES\""
                        echo "GENMD_FILE_EXCLUDES=\"$GENMD_FILE_EXCLUDES\""
                        echo "GENMD_FILE_INCLUDES=\"$GENMD_FILE_INCLUDES\""
                    } > "$config_file"
                    echo "INFO ($my_name): Configuration saved to $config_file" >&2
                    shift 2
                fi
            else
                echo "Error: --config requires an action (save|load) and a filename." >&2
                display_help
            fi
            ;;
        -d|--debug)
            if [[ "$2" =~ ^[0-9]$ ]]; then
                debug_level="$2"
                if [[ "$debug_level" -eq 9 ]]; then
                    set -x
                fi
                shift 2
            else
                echo "Error: Debug level must be between 0 and 9." >&2
                display_help
            fi
            ;;
        -h|--help)
            display_help
            ;;
        -e|--exclude)
            if [[ -f "$2" ]]; then
                # Read exclude patterns from file, ignoring comments
                mapfile -t user_excludes < <(grep -v '^#' "$2")
                dir_excludes+=("${user_excludes[@]}")
            elif [[ -n "$2" ]]; then
                # Split the input string on '|' and add each pattern separately
                IFS='|' read -r -a user_excludes <<< "$2"
                dir_excludes+=("${user_excludes[@]}")
            else
                echo "Error: --exclude requires a file or string." >&2
                display_help
            fi
            shift 2
            ;;
        -f|--file)
            if [[ -f "$2" ]]; then
                # Read exclude patterns from file, ignoring comments
                mapfile -t user_excludes < <(grep -v '^#' "$2")
                file_excludes+=("${user_excludes[@]}")
            elif [[ -n "$2" ]]; then
                # Split the input string on '|' and add each pattern separately
                IFS='|' read -r -a user_excludes <<< "$2"
                file_excludes+=("${user_excludes[@]}")
            else
                echo "Error: --file requires a file or string." >&2
                display_help
            fi
            shift 2
            ;;
        -i|--include)
            if [[ -f "$2" ]]; then
                # Read include patterns from file, ignoring comments
                mapfile -t includes < <(grep -v '^#' "$2")
                file_includes+=("${includes[@]}")
            elif [[ -n "$2" ]]; then
                # Split the input string on '|' and add each pattern separately
                IFS='|' read -r -a includes <<< "$2"
                file_includes+=("${includes[@]}")
            else
                echo "Error: --include requires a file or string." >&2
                display_help
            fi
            shift 2
            ;;
        -p|--pattern)
            if [[ -f "$2" ]]; then
                # Read pattern excludes from file, ignoring comments
                mapfile -t patterns < <(grep -v '^#' "$2")
                pattern_excludes+=("${patterns[@]}")
            elif [[ -n "$2" ]]; then
                # Split the input string on '|' and add each pattern separately
                IFS='|' read -r -a patterns <<< "$2"
                pattern_excludes+=("${patterns[@]}")
            else
                echo "Error: --pattern requires a file or string." >&2
                display_help
            fi
            shift 2
            ;;
        -o|--output)
            output_filename="$GENMD_BASE/$2"
            shift 2
            ;;
        -n|--dry-run)
            dry_run=true
            shift
            ;;
        -v|--verbose)
            verbose=true
            shift
            ;;
        -s|--settings)
            if [[ -n "$2" && ! "$2" =~ ^- ]]; then
                IFS=',' read -r -a modes <<< "$2"
                settings_modes+=("${modes[@]}")
                shift 2
            else
                # Default to 'info' mode if no argument is provided
                settings_modes+=("info")
                shift
            fi
            ;;
        --)
            shift
            break
            ;;
        *)
            echo "Error: Unknown option '$1'" >&2
            display_help
            ;;
    esac
done

# Remove duplicates from exclusion and inclusion lists
remove_duplicates dir_excludes
remove_duplicates file_excludes
remove_duplicates pattern_excludes
remove_duplicates file_includes

# After all options have been processed, handle the settings_modes
if [[ ${#settings_modes[@]} -gt 0 ]]; then
    display_settings "${settings_modes[@]}"
fi

# Set default output file if not set
output_filename="${output_filename:-$GENMD_BASE/combined_source.md}"

# Truncate the output file
: > "$output_filename"

# Debug: Show final directory exclusions
echo "DEBUG ($my_name): Final directory exclusions: ${dir_excludes[*]}" >&2

# Generate file tree markdown
generate_filetree "$output_filename" "${dir_excludes[@]}"

# Build the file list
declare -a final_files
build_file_list final_files file_includes file_excludes dir_excludes pattern_excludes

# Debug: Show final files to be processed
echo "DEBUG ($my_name): Final files to process: ${final_files[*]}" >&2

# Process the files and generate markdown
process_files "$output_filename" final_files